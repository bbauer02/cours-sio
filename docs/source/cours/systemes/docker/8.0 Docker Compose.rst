8.0 Docker Compose
#################################

Docker Compose permet de gérer des applications complexes, c'est à dire par exemple des applications qui dialoguent les unes avec les autres. 
Très simplement nous pouvons utiliser Docker Compose : Grâce à une configuration sous forme de fichier `YAML` dont le nom par défaut est `docker-compose.yml` par défaut. 

8.1 Structure du fichier ``docker.compose.yml``
####################################################

Dans ce fichier nous définirons l'ensemble des éléments d'une apllication : 

* Les services.
* Les volumes.
* Les Networks qui permettent d'isoler les services. 
* Les secrets (données sensibles nécessaires au fonctionnement de l'application, pris en compte seulement dans un cluster Swarm).
* Les configs (configuration sensibles nécessaires au fonctionnement de l'application, pris en compte seulement dans un cluster Swarm).


Examinons maintenant une application web branchée à une API configurée dans le fichier ``docker-compose.yml`` :

.. code-block:: 
  :caption: Exemple d'application web
  :linenos:
  :emphasize-lines: 0
   
    version: '3.9'
    volumes:
      data:
    networks:
      frontend:
      backend:
    services:
      web:
        images: org/web:2.3
        networks:
          - frontend
        ports:
          - 80:80
      api:
        image: org/api 
        networks:
          - backend
          - frontend
      db: 
        image: mongo 
        volumes: 
          - data:/data/db 
        networks:
          - backend 

Analysons les principales clées de notre fichier : 

* ``Version`` correspond à la version du format Compose à mettre en relation avec la version du **Docker Daemon** de la machine hôte qui va être utilisée pour déployer notre application. Si on utilise la fernière version de compose avec un Daemon plus ancien, il y a certaines options écrites dans le ``docker-compose.yml`` qui ne seront pas prises en compte. 

* ``Volumes`` permet de définir un volume, que l'on appelle ici, **data** et qui sera utilisé dans un service par la suite. Par défaut, ce volume utilise le driver local, qui va donc créer un répertoire sur la machine hôte. 

* ``Networks`` permet de créer des réseaux qui serviront à isoler des groupes de services. 

* ``Services`` contient la définition des services nécessaires au fonctionnement de notre application. Ici, nous avons nos 3 services : ``WEB``, ``API``, ``DB``.

Pour chaque service on spécifie l'image utilisée, les volumes pour la persistance des données.Le service ``DB`` est le seul a persister les données et montera le volume ``data`` dans le répertoire ``/data/db`` du container qui sera lancé. 

Pour chaque service, on définit aussi les réseaux attachés avec la clé ``Networks``. 
Dans notre exemple : le service ``API```doit pouvoir communiquer avec le service ``WEB`` et ``DB``. Donc il faut lui donner accès aux deux réseaux attachés à ces services : ``backend`` et ``frontend``.

En isolant ainsi les services, on s'assure qu'ils ne puissent pas avoir accès à des services dont ils n'ont pas besoin d'avoir accès directement. 
Comme le service ``WEB``, qui ne doit pas pouvoir accès au service ``DB`` directement. Cela ajoute un niveau de sécurité au cas où l'un des services serait compromis. 

La clé ``ports`` publie les ports nommés vers l'extérieur pour le service qui a besoin d'être joins, comme le serveur ``Web`` et son port 80.

De nombreuses options sont encore disponibles pour la définition d'un service dans le format ``compose``. 

Voici une liste des plus utilisées : 

* Image utilisée par le container du service. 
* Nombre de réplicas, c'est à dire le nombre de container identique qui sera lancé pour le service. En augmentant le nombre de container, on pourra traiter les piques de charge par exemple. 
* Les ports publiés à l'extérieur par les services qui ont besoin d'être accessible par l'extérieur.
* La définition d'un Health check pour vérifier l'état de santé d'un service. 
* Les stratégies de redémarrage de façon à définir que faire si un container a planté par exemple.
* Contraintes de déploiement (dans un contexte de SWARM uniquement), par exemple pour imposer qu'un container doit tourner sur une machine contenant un disque SSD.
* Contraintes des mises à jour (dans un contexte de SWARM uniquement).

Un des avantages qu'il y a à déployer une application à travers le fichier docker-compose.yml, c'est qu'elle peut être déployer sur n'importe quel environnement. 
En utilisant le binaire ``compose``, un développeur peut installer sur une machine son application, avec son environnement de développement complet. 

8.2 Le binaire ``docker-compose``
####################################################

Le binaire ``docker-compose`` est utilisé pour gérer une application qui est gérée selon le format ``docker-compose.yml``.
Cet outil est indépendant du **docker daemon** qui est souvent livré en même temps (Docker for Mac, Docker for Windows).

.. code-block:: 
  :caption: Utilisation de ``docker-compose``
  :linenos:
  :emphasize-lines: 0

  docker-compose [-f <arg>...] [options] [COMMAND] [ARGS...]

Il y a plusieurs éléments qui peuvent être fourni au binaire : 

* Le chemin d'accès aux fichiers dans lequel est défini l'application. ( par défault il s'agit du fichier : ``docker-compose.yml`` du répertoire courant)
* Des options, comme des chemins d'accès à des certificats et clés TLS ou l'adresse de l'hôte à contacter. 
* Une commande pour gérer l'application.
* Des arguments pour cette commande.

On peut avoir plusieurs fichiers pour spécifier une configuration différente par environnement de développement.

.. list-table:: title
  :widths: 25 25
  :header-rows: 1

  * - Commande 
    - Utilisation  
  * - up / down 
    - Création / Suppression d'une application (services, volumes, réseaux)
  * - start / stop
    - Démarrage / arrête d'une application  
  * - build
    - Build des images des services (si instruction build utilisée)
  * - pull
    - Téléchargement d'une image 
  * - logs 
    - Visualisation des logs de l'application 
  * - scale
    - Modification du nombre de container pour un service 
  * - ps 
    - Liste les containers de l'application 
  