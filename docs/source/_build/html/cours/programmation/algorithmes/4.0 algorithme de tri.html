
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>4.0 Algorithmes de tri &#8212; Cours BTS SIO 0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="prev" title="3.0 Validité et coût" href="3.0%20validit%C3%A9%20et%20co%C3%BBt.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="algorithmes-de-tri">
<h1>4.0 Algorithmes de tri<a class="headerlink" href="#algorithmes-de-tri" title="Permalink to this headline">¶</a></h1>
<p>Les algorithmes de tri sont fondamentaux dans la gestion des données et permettent l’accès à des informations dans des délais très brefs. Aussi l’ingéniosité des informaticiens a été mise en œuvre pour élaborer ceux qui nécessitent le moins d’opérations.</p>
<p>Trier des données, c’est les ranger suivant un ordre défini au préalable.
Par exemple avec des données numériques, nous pouvons trier ces données en utilisant l’ordre défini en mathématiques : <span class="math notranslate nohighlight">\(a\)</span> est avant <span class="math notranslate nohighlight">\(b\)</span> si <span class="math notranslate nohighlight">\(b - a\)</span> est positif (<span class="math notranslate nohighlight">\(a &lt; b\)</span>  si <span class="math notranslate nohighlight">\(b - a &gt; 0\)</span> ).</p>
<p>Si nous trions l’ensemble de nombres <span class="math notranslate nohighlight">\({3,8,5,2}\)</span>, nous obtenons l’ensemble <span class="math notranslate nohighlight">\({2,3,5,8}\)</span> et nous disons que les nombres sont rangés suivant l’ordre croissant. Si nous les rangeons dans l’ordre inverse, nous parlons d’ordre décroissant.</p>
<p>Les lettres de notre alphabet sont rangées suivant l’ordre alphabétique. Nous pouvons alors trier un ensemble de mots, par exemple l’ensemble de quatre mots <span class="math notranslate nohighlight">\({bonjour, bon, table, assiette}\)</span>, en suivant l’ordre lexicographique qui utilise lui-même l’ordre alphabétique. Nous obtenons l’ensemble  <span class="math notranslate nohighlight">\({assiette, bon, bonjour, table}\)</span>.</p>
<p>Des suites d’instructions permettant d’effectuer un tri ont été étudiées dès les années 1940 sur les premiers ordinateurs. Durant cette période, l’américaine <strong>Betty Holberton</strong> était l’une des six programmatrices de l’ENIAC, le premier ordinateur entièrement électronique.</p>
<p>Elle travaillait sur différents codes et applications et c’est à ce moment qu’elle développa sans doute <strong>le premier programme de tri</strong>. Elle travaillera plus tard avec <strong>Grâce Hopper</strong> sur les langages de programmation <strong>COBOL</strong> et <strong>Fortran</strong>.</p>
<p>Dans les algorithmes présentés plus loin, nous procédons par des comparaisons successives entre deux éléments et effectuons éventuellement une permutation des deux éléments comparés.</p>
<p>Le nombre de <strong>permutations</strong> est donc toujours <strong>inférieur au nombre de comparaisons</strong>. Le <strong>coût</strong> ou la <strong>complexité</strong> d’un algorithme est dans ce cas un <em>ordre de grandeur du nombre de comparaisons</em> effectuées par cet algorithme.</p>
<p>Pour un algorithme donné, le coût peut être différent suivant les cas à traiter, il y a des cas favorables, et d’autres non. Ce coût doit absolument être évalué avant d’écrire un programme et l’exécuter car suivant la taille de l’ensemble de données, <strong>le temps de calcul avec une machine peut devenir rédhibitoire</strong>.</p>
<p>Prenons trois nombres tout distincts <span class="math notranslate nohighlight">\(a\)</span>, <span class="math notranslate nohighlight">\(b\)</span> et <span class="math notranslate nohighlight">\(c\)</span>.</p>
<p>Il y a six manières de ranger ces trois nombres :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\((a,b,c)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\((a,c,b)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\((b,a,c)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\((b,c,a)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\((c,a,b)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\((c,b,a)\)</span></p></li>
</ul>
<p>Si en comparant <span class="math notranslate nohighlight">\(a\)</span> et <span class="math notranslate nohighlight">\(b\)</span>, nous obtenons <span class="math notranslate nohighlight">\(a &lt; b\)</span>, alors le nombre de rangements possibles est <strong>divisé par deux</strong>, il n’en reste plus que trois :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\((a, b, c)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\((a, c, b)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\((c, a, b)\)</span></p></li>
</ul>
<p>La comparaison de <span class="math notranslate nohighlight">\(a\)</span> et <span class="math notranslate nohighlight">\(c\)</span> permet de conclure si <span class="math notranslate nohighlight">\(c &lt; a\)</span>, sinon il faut une troisième comparaison entre <span class="math notranslate nohighlight">\(b\)</span> et <span class="math notranslate nohighlight">\(c\)</span>.</p>
<p>Pour quatre nombres <span class="math notranslate nohighlight">\((a, b, c, d)\)</span>, il y a <strong>quatre</strong> fois plus de rangements possibles.</p>
<p>En effet, pour chacun des six rangements de <span class="math notranslate nohighlight">\(a\)</span>, <span class="math notranslate nohighlight">\(b\)</span> et <span class="math notranslate nohighlight">\(c\)</span>, il y a quatre places possibles pour <span class="math notranslate nohighlight">\(d\)</span> :
* en premier,
* soit entre le premier et le deuxième,
* soit entre le deuxième et le troisième,
* soit en dernier.</p>
<p>Après une première comparaison, il reste <strong>douze</strong> rangements possibles, et après une seconde comparaison il en reste <strong>six</strong>. Au total, nous avons donc cinq comparaisons au maximum.</p>
<p>Le nombre total <span class="math notranslate nohighlight">\(r\)</span> de rangements possibles de <span class="math notranslate nohighlight">\(n\)</span> données vaut <span class="math notranslate nohighlight">\(n * (n - 1) * 2 * 1\)</span> noté <span class="math notranslate nohighlight">\(n!\)</span>, <span class="math notranslate nohighlight">\(n\)</span> factoriel.</p>
<p>Après chaque comparaison, ce nombre de rangements possibles est divisé par 2.
Donc après <span class="math notranslate nohighlight">\(k\)</span> comparaison, il est divisé par <span class="math notranslate nohighlight">\(2k\)</span>.
Le tri est terminé lorsqu’il ne  reste plus qu’un seul rangement possible, c’est-à-dire dès que <span class="math notranslate nohighlight">\(2k &gt; r\)</span>.</p>
<p><strong>Remarque</strong> : en binaire, 2 s’écrit avec <span class="math notranslate nohighlight">\(k +1\)</span> bits. Donc le nombre de comparaisons est de l’ordre du nombre de chiffres dans l’écriture binaire de <span class="math notranslate nohighlight">\(r\)</span>.</p>
<p>Il est intéressant de faire un test avec un jeu de 32 cartes, un ordre étant défini sur l’ensemble des cartes.
On utilise un ordre sur les valeurs, 7, 8, 9, 10, valet, dame, roi, as, et pour ordonner deux cartes de même valeur, un ordre sur les couleurs. Comme pour l’ordre lexicographique avec des mots de deux lettres, il s’agit d’un ordre sur les couples <span class="math notranslate nohighlight">\((valeur, couleur)\)</span>.</p>
<p>On distribue une dizaine de cartes à une personne et on lui demande d’ordonner les cartes. On recommence avec d’autres personnes.
Avec chaque personne, on essaie de dégager une stratégie, <strong>un algorithme de tri</strong>. On peut alors remarquer que des algorithmes comme le <strong>tri sélection</strong>, le <strong>tri insertion</strong>, ainsi que d’autres plus élaborés sont utilisés et souvent à tour de rôle pour un tri donné.</p>
<p>L’idée “<strong>diviser pour régner</strong>” est présente.</p>
<section id="tri-par-selection">
<h2>4.1 Tri par sélection<a class="headerlink" href="#tri-par-selection" title="Permalink to this headline">¶</a></h2>
<p>En anglais, cet algorithme est nommé “<em>selection sort</em>”.</p>
<section id="le-principe">
<h3>Le principe<a class="headerlink" href="#le-principe" title="Permalink to this headline">¶</a></h3>
<p>On dispose de <span class="math notranslate nohighlight">\(n\)</span> données.
On cherche la plus petite donnée et on la place en première position, puis on cherche la plus petite donnée parmi les données restantes et on la place en deuxième position, et ainsi de suite.</p>
<p>Si les données sont les éléments d’une liste <span class="math notranslate nohighlight">\(liste\)</span>, l’algorithme consiste donc à faire varier un indice <span class="math notranslate nohighlight">\(i\)</span> de <span class="math notranslate nohighlight">\(0\)</span> à <span class="math notranslate nohighlight">\(n - 2\)</span>. Pour chaque valeur de <span class="math notranslate nohighlight">\(i\)</span>, on cherche dans la tranche liste <span class="math notranslate nohighlight">\([i : n]\)</span> le plus petit élément et on l’échange avec <span class="math notranslate nohighlight">\(liste[i]\)</span>.</p>
<p>L’algorithme de <strong>tri par sélection</strong> est souvent utilisé pour <strong>trier à la main des objets</strong>, comme des cartes à jouer, des livres, etc.</p>
<div class="literal-block-wrapper docutils container" id="id1">
<div class="code-block-caption"><span class="caption-text"><strong>Algorithme du minimum</strong></span><a class="headerlink" href="#id1" title="Permalink to this code">¶</a></div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>i_mini ← i (indice du plus petit élèment)
mini ← liste[i]
pour j variant de i+1 à n-1
    si liste[j] &lt; mini
        i_mini ← j
        mini ← liste[j]
</pre></div>
</div>
</div>
<p>Pour obtenir un algorithme du tri sélection, il ne reste qu’à insérer l’algorithme du minimum dans une boucle où <span class="math notranslate nohighlight">\(i\)</span> varie de <span class="math notranslate nohighlight">\(0\)</span> à <span class="math notranslate nohighlight">\(n-2\)</span> et pour chaque valeur de <span class="math notranslate nohighlight">\(i\)</span> à faire échange de <span class="math notranslate nohighlight">\(liste[i]\)</span> avec <span class="math notranslate nohighlight">\(liste[i_mini]\)</span>.</p>
<p>La donnée en entrée est une liste de <span class="math notranslate nohighlight">\(n\)</span> éléments. Il n’y a pas de résultat renvoyé en sortie, la liste est modifiée en place.</p>
<div class="literal-block-wrapper docutils container" id="id2">
<div class="code-block-caption"><span class="caption-text"><strong>Algorithme du tri</strong></span><a class="headerlink" href="#id2" title="Permalink to this code">¶</a></div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>POUR i VARIANT de i à n-2
    i_mini ← i
    mini ← liste[i]
    POUR j VARIANT de i+1 à n-1
        SI liste[j] &lt; mini
            i_mini ← j
            mini ← liste[j]
    ECHANGER liste[i] et liste[i_mini]
</pre></div>
</div>
</div>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="k">def</span> <span class="nf">tri_selection</span><span class="p">(</span><span class="n">liste</span><span class="p">)</span> <span class="p">:</span>
<span class="linenos">2</span>  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">liste</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span> <span class="p">):</span>
<span class="linenos">3</span>      <span class="n">i_mini</span> <span class="o">=</span> <span class="n">i</span>
<span class="linenos">4</span>      <span class="n">mini</span> <span class="o">=</span> <span class="n">liste</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="linenos">5</span>      <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">liste</span><span class="p">))</span> <span class="p">:</span>
<span class="linenos">6</span>          <span class="k">if</span><span class="p">(</span><span class="n">liste</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">mini</span> <span class="p">)</span> <span class="p">:</span>
<span class="linenos">7</span>              <span class="n">i_mini</span> <span class="o">=</span> <span class="n">j</span>
<span class="linenos">8</span>              <span class="n">mini</span> <span class="o">=</span> <span class="n">liste</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
<span class="linenos">9</span>      <span class="n">liste</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">liste</span><span class="p">[</span><span class="n">i_mini</span><span class="p">]</span> <span class="o">=</span> <span class="n">liste</span><span class="p">[</span><span class="n">i_mini</span><span class="p">],</span> <span class="n">liste</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></div>
</div>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">Cours BTS SIO</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Systèmes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../systemes/docker/sommaire_docker.html">La plateforme Docker</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Programmation</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../python/sommaire_python.html">Python</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="sommaire_algorithmes.html">Algorithmes</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="sommaire_algorithmes.html">Algorithmes</a><ul>
      <li>Previous: <a href="3.0%20validit%C3%A9%20et%20co%C3%BBt.html" title="previous chapter">3.0 Validité et coût</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, Bauer Baptiste.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.4.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../../_sources/cours/programmation/algorithmes/4.0 algorithme de tri.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>