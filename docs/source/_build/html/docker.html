
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>3.0 Les containers avec Docker &#8212; Cours BTS SIO 0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="les-containers-avec-docker">
<h1>3.0 Les containers avec Docker<a class="headerlink" href="#les-containers-avec-docker" title="Permalink to this headline">¶</a></h1>
<p>Après avoir présenté la plateforme Docker, nous allons voir comment créer des <strong>containers</strong> en ligne de commande pour lancer des services en tâche de fond et/ou pour rendre disponible dans un container des repertoires de la <strong>machine hôte</strong>.</p>
<p>Nous verrons comment lancer un container dans un mode d’<strong>accès privilégié</strong>, ainsi que les commandes de bases pour la gestion du cycle de vie des containers.</p>
<p>Avant la 1.13, lancer un <strong>container</strong> s’effectuait avec la commande : <code class="docutils literal notranslate"><span class="pre">Docker</span> <span class="pre">Run</span></code> sans le mot clé <code class="docutils literal notranslate"><span class="pre">container</span></code>.
Il est toujours possible de le faire.
Mais maintenant les commandes ont été regroupé aux composant auquel elles se rapportent. C’est la raison pour laquelle le mot clé <code class="docutils literal notranslate"><span class="pre">container</span></code> a été rajouté pour les commandes relatifs à la gestion des containers.
<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">container</span> <span class="pre">run</span> <span class="pre">[OPTIONS]</span> <span class="pre">IMAGE</span> <span class="pre">[COMMAND]</span> <span class="pre">[ARG]</span></code>
D’autres groupes de commande existent et nous les étudierons plus tard.</p>
<section id="hello-world">
<h2>3.1 Hello World<a class="headerlink" href="#hello-world" title="Permalink to this headline">¶</a></h2>
<p>Lançons notre premier container <strong>Hello-World</strong>.</p>
<img alt="_images/image62.png" src="_images/image62.png" />
<p>Ouvrez un <strong>terminal</strong> et tapez :</p>
<div class="highlight-language notranslate"><div class="highlight"><pre><span></span>docker container run hello-world
</pre></div>
</div>
<img alt="_images/image63.png" src="_images/image63.png" />
<p>Le client demande au <strong>daemon</strong> (processus) de lancer un <strong>container</strong> basé sur l’image <strong>Hello-World</strong> .
Cette image ,n’étant pas disponible en local, est téléchargée et le <strong>processus</strong> présent dans cette image est automatiquement exécuté.</p>
<p>Et dans le cas de notre <strong>Hello-world</strong>, il s’agit seulement d’écrire du texte sur la sortie standard : <strong>Hello from Docker</strong> suivi d’un texte.</p>
<p>Cet exemple est simple mais il met en avant le mécanisme sous-jacent.
A la fin du texte on nous demande d’essayer un exemple plus ambitieux, c’est ce que nous allons faire par la suite.</p>
<p>Expérimentez la commande : <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">container</span> <span class="pre">run</span> <span class="pre">hello-world</span></code> sur votre machine</p>
</section>
<section id="ubuntu-sous-docker">
<h2>3.2 Ubuntu sous docker<a class="headerlink" href="#ubuntu-sous-docker" title="Permalink to this headline">¶</a></h2>
<p>Nous pouvons lancer un autre container basé sur l’image de <strong>Ubuntu</strong> et lui demander d’afficher <code class="docutils literal notranslate"><span class="pre">Hello</span></code> dans  le contexte de cette image.</p>
<div class="highlight-language notranslate"><div class="highlight"><pre><span></span>docker container run ubuntu echo hello
</pre></div>
</div>
<img alt="_images/image11.png" src="_images/image11.png" />
<p>Analyser le contenu des cadres ci-dessus.
A quelles actions correspondent-ils ?</p>
</section>
<section id="un-container-dans-un-mode-interactif">
<h2>3.2 Un container dans un mode Interactif<a class="headerlink" href="#un-container-dans-un-mode-interactif" title="Permalink to this headline">¶</a></h2>
<p>Le mode <strong>interactif</strong> permet d’avoir accès à un <code class="docutils literal notranslate"><span class="pre">shell</span></code> depuis le client local  qui tourne dans le <strong>contexte du container</strong>.</p>
<p>Pour cela il faut rajouter deux options à notre commande :</p>
<p><code class="docutils literal notranslate"><span class="pre">-t</span></code> qui permet d’allouer un pseudo terminal à notre container.</p>
<p><code class="docutils literal notranslate"><span class="pre">-i</span></code> qui va permettre de laisser l’entrée standard du container ouverte.</p>
<p>Nous allons utiliser l’image <strong>Ubuntu</strong> qui contient les binaires et les bibliothèques du système d’exploitation Ubuntu. Le processus du <strong>container</strong> s’exécutera donc dans cette environnement, c’est-à-dire dans le <strong>système de fichier</strong> qui est amené par le système Ubuntu.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">run</span> <span class="o">-</span><span class="n">t</span> <span class="o">-</span><span class="n">i</span> <span class="n">ubuntu</span> <span class="n">bash</span>
</pre></div>
</div>
<p>ou</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">run</span> <span class="o">-</span><span class="n">ti</span> <span class="n">ubuntu</span> <span class="n">bash</span>
</pre></div>
</div>
<img alt="_images/image12.png" src="_images/image12.png" />
<p>Nous voyons que nous avons accès à un <code class="docutils literal notranslate"><span class="pre">shell</span></code> ( <em>coquille en anglais, interface système</em>).
Nous reconnaissons sans peine le prompt <strong>Ubuntu/Linux</strong> dans lequel nous pouvons écrire par exemple une commande Linux : <code class="docutils literal notranslate"><span class="pre">ls</span></code></p>
<p>Tapez dans le <code class="docutils literal notranslate"><span class="pre">shell</span></code>, la commande : <code class="docutils literal notranslate"><span class="pre">cat</span> <span class="pre">/etc/issue</span></code>.</p>
<blockquote>
<div><p>Quelle information obtenez-vous ?</p>
</div></blockquote>
<p>Pour sortir du container on va tuer le processus avec la commande : <code class="docutils literal notranslate"><span class="pre">exit</span></code></p>
<p>Nous aurions pu faire la même chose en utilisant une autre image que celle d’Ubuntu.
Par exemple :
Nous souhaitons lancer un container basé sur la distribution <strong>Linux Alpine</strong>.
C’est une distribution légère et sécurisée.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">run</span> <span class="o">-</span><span class="n">t</span> <span class="o">-</span><span class="n">i</span> <span class="n">alpine</span>
</pre></div>
</div>
<p>ou</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">run</span> <span class="o">-</span><span class="n">ti</span> <span class="n">alpine</span>
</pre></div>
</div>
<img alt="_images/image13.png" src="_images/image13.png" />
<p>Vous savez maintenant lancer un <code class="docutils literal notranslate"><span class="pre">shell</span></code> interactif dans un container.</p>
<p>Quand on lance un <strong>container</strong> avec seulement la commande <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">container</span> <span class="pre">run</span></code>
par défaut le container est exécuté en <strong>foreground</strong>, mais si l’on veut l’exécuter en <strong>background</strong>, c’est-à-dire en tâche de fond, il faudra utiliser l’option <code class="docutils literal notranslate"><span class="pre">-d</span></code> et la commande retournera alors l’ <strong>identifiant</strong> du conteneur que l’on pourra utiliser par la suite pour effectuer différentes actions.</p>
<p>Par exemple nous pouvons lancer un container basé sur l’image <code class="docutils literal notranslate"><span class="pre">nginx</span></code>, un <strong>serveur http</strong>.</p>
<section id="container-nginx-en-foreground">
<h3>Container NGINX en <strong>foreground</strong><a class="headerlink" href="#container-nginx-en-foreground" title="Permalink to this headline">¶</a></h3>
<p>Création du <strong>conteneur</strong> en <strong>foreground</strong>, cela signifie que l’on ne récupère pas la main</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">run</span> <span class="n">nginx</span>
</pre></div>
</div>
<img alt="_images/image14.png" src="_images/image14.png" />
<p>Le conteneur est lancé et occupe notre console. Nous n’avons pas la main.</p>
</section>
<section id="container-nginx-en-background">
<h3>Container NGINX en <strong>background</strong><a class="headerlink" href="#container-nginx-en-background" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">run</span> <span class="o">-</span><span class="n">d</span> <span class="n">nginx</span>
</pre></div>
</div>
<img alt="_images/image15.png" src="_images/image15.png" />
<p>Nous voyons ici que nous avons <strong>NGINX</strong> qui tourne en tâche de fond et nous pouvons accéder à ce container par la suite grâce à son <strong>identifiant</strong>.</p>
<p>Nous pourrions aussi accéder à ce serveur web depuis un <strong>navigateur</strong>.
Cela n’est actuellement pas possible car nous n’avons pas publié de <strong>port</strong>.</p>
</section>
</section>
<section id="publication-de-port">
<h2>3.3 Publication de port.<a class="headerlink" href="#publication-de-port" title="Permalink to this headline">¶</a></h2>
<p>La publication d’un port est utilisée pour qu’un <strong>container</strong> puisse être accessible depuis l’extérieur.
Afin de publier un port nous utilisons l’option <code class="docutils literal notranslate"><span class="pre">-p</span> <span class="pre">HOST_PORT:CONTAINER_PORT</span></code>.</p>
<p>Cela permet de publier un <strong>port du conteneur</strong> sur un <strong>port de la machine hôte</strong>.</p>
<p>L’option <code class="docutils literal notranslate"><span class="pre">-P</span></code> quant à elle laisse le choix du port au <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">démon</span></code>.</p>
<p>Reprenons notre container <strong>NGINX</strong> qui est un serveur <strong>http</strong>.
Par défaut, <strong>NGINX</strong> est un processus qui se lance sur le <strong>port 80</strong> dans le container.
Si nous souhaitons accéder à notre container depuis <strong>un navigateur de la machine hôte</strong> sur le <strong>port 8080</strong> de la machine hôte,
nous lançerons le container <strong>nginx</strong> avec la commande suivante :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">run</span> <span class="o">-</span><span class="n">d</span> <span class="o">-</span><span class="n">p</span> <span class="mi">8080</span><span class="p">:</span><span class="mi">80</span> <span class="n">nginx</span>
</pre></div>
</div>
<img alt="_images/image16.png" src="_images/image16.png" />
<p>Maintenant, nous pouvons ouvrir notre navigateur sur l’adresse : <a class="reference external" href="http://localhost:8080">http://localhost:8080</a></p>
<img alt="_images/image17.png" src="_images/image17.png" />
</section>
<section id="bind-mount">
<h2>3.4 Bind-mount<a class="headerlink" href="#bind-mount" title="Permalink to this headline">¶</a></h2>
<p>Nous allons maintenant voir comment <strong>monter un répertoire de la machine hôte</strong> dans un container.</p>
<p>Cela s’effectue grâce à l’option <code class="docutils literal notranslate"><span class="pre">-v</span> <span class="pre">&lt;HOST_PATH&gt;:&lt;CONTAINER_PATH&gt;</span></code></p>
<p>Il existe une autre notation avec l’option <code class="docutils literal notranslate"><span class="pre">--mount</span> <span class="pre">type=bind,</span> <span class="pre">src=&lt;HOST_PATH&gt;,dst=&lt;CONTAINER_PATH&gt;</span></code></p>
<p>Cela permet de partager,par exemple,le code source d’un programme présent sur une <strong>machine hôte</strong> avec des <strong>containers</strong>
ou de monter la <strong>socket Unix</strong> du <strong>daemon Docker</strong> (<code class="docutils literal notranslate"><span class="pre">/var/run/docker.sock</span></code>) pour permettre à un container de dialoguer avec le <strong>daemon</strong>.</p>
<section id="exemple-1-monter-un-dossier-www">
<h3>3.4.1 Exemple 1 : monter un dossier ‘www’<a class="headerlink" href="#exemple-1-monter-un-dossier-www" title="Permalink to this headline">¶</a></h3>
<p>Quand vous développez une application et que vous modifiez le code source, il peut être intéressant que cela soit pris en compte dans le conteneur.
C’est le cas lors du développement d’une <strong>application web</strong>.
Nos <strong>fichiers sources</strong> sont sur une <strong>machine locale</strong>, et dans <strong>un conteneur</strong> nous avons un serveur <strong>WEB</strong> avec <strong>NGINX</strong> par exemple.
Nous allons alors monter le dossier <code class="docutils literal notranslate"><span class="pre">www</span></code> local dans le <strong>container</strong>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>docker container run -v $PWD/www:/usr/share/nginx/html -d -p 80:80 nginx
</pre></div>
</div>
<p>Ou</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>docker container run –mount type=bind,src=$PWD/www,dst=/usr/share/nginx/html -d -p 80:80 nginx
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">$PWD</span></code> est une variable d’environnement qui va être créé par le <strong>SHELL</strong> et prendra comme valeur le <strong>chemin du répertoire courant</strong> dans lequel la commande a été lancé.</p>
<img alt="_images/image18.png" src="_images/image18.png" />
</section>
<section id="exemple-2-interagir-avec-le-docker-daemom">
<h3>3.4.2 Exemple 2 : Intéragir avec le Docker Daemom<a class="headerlink" href="#exemple-2-interagir-avec-le-docker-daemom" title="Permalink to this headline">¶</a></h3>
<p>Dans cet exemple nous allons voir comment lier(bind) <code class="docutils literal notranslate"><span class="pre">/var/run/docker.sock</span></code>.
Ce qui nous permettra d’interagir avec le <code class="docutils literal notranslate"><span class="pre">Docker</span> <span class="pre">Daemon</span></code> directement depuis le container et cela nous donnera accès à l’ <strong>API du Daemon</strong>.</p>
<img alt="_images/image19.png" src="_images/image19.png" />
<section id="pour-linux-uniquement">
<h4>Pour LINUX UNIQUEMENT<a class="headerlink" href="#pour-linux-uniquement" title="Permalink to this headline">¶</a></h4>
<p>Créons donc un simple container : avec l’image d’ <strong>Alpine</strong>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">run</span> <span class="o">--</span><span class="n">rm</span> <span class="o">-</span><span class="n">it</span> <span class="o">--</span><span class="n">name</span> <span class="n">admin</span> <span class="o">-</span><span class="n">v</span> <span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">run</span><span class="o">/</span><span class="n">docker</span><span class="o">.</span><span class="n">sock</span><span class="p">:</span><span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">run</span><span class="o">/</span><span class="n">docker</span><span class="o">.</span><span class="n">sock</span> <span class="n">alpine</span>
</pre></div>
</div>
<p>Maintenant que le container est monté, et branché au <code class="docutils literal notranslate"><span class="pre">Docker</span> <span class="pre">Daemon</span></code>, nous pouvons lui envoyer des requêtes.</p>
<p><strong>Depuis le Shell</strong>:
Installons <strong>CURL</strong> :</p>
<p><code class="docutils literal notranslate"><span class="pre">apk</span> <span class="pre">add</span> <span class="pre">curl</span></code> pour ajouter l’utilitaire <code class="docutils literal notranslate"><span class="pre">CURL</span></code>.</p>
<p>Nous allons lancer une requête <strong>http POST</strong> sur le <code class="docutils literal notranslate"><span class="pre">Docker</span> <span class="pre">DAEMON</span></code> :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>curl -X POST –unix-socket /var/run/docker.sock -d &#39;{&quot;Image&quot;:&quot;nginx:1.12.2&quot;}&#39; -H &#39;Content-Type: application/json&#39; http://localhost/containers/create
</pre></div>
</div>
<p>Cela aura pour effet de demander au <strong>Docker Daemon</strong> de créer un nouveau container avec l’image <strong>NGINX version 1.12.2</strong>.</p>
<p>Le paramètre <code class="docutils literal notranslate"><span class="pre">-X</span> <span class="pre">POST</span></code> permet d’effectuer quel type de requête <code class="docutils literal notranslate"><span class="pre">http</span></code> ?
Sous quel format sont envoyés les instructions de configuration de l’image <strong>Docker</strong> à créer ?</p>
<p>Pour lancer le container depuis le container <strong>ADMIN</strong> :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>curl -XPOST –unix-socket /var/run/docker.sock http://localhost/containers/6b24...283b/start
</pre></div>
</div>
<p>Dans cette commande, à votre avis à quoi corresponde la chaine de caractère : <code class="docutils literal notranslate"><span class="pre">6b24...283b</span></code> ?</p>
</section>
<section id="pour-windows-uniquement">
<h4>Pour WINDOWS UNIQUEMENT<a class="headerlink" href="#pour-windows-uniquement" title="Permalink to this headline">¶</a></h4>
<p>Bientôt disponible ….</p>
</section>
</section>
<section id="exemple-3-ecouter-les-actions-demandees-au-docker-daemon">
<h3>3.4.3 Exemple 3 : Ecouter les actions demandées au Docker Daemon<a class="headerlink" href="#exemple-3-ecouter-les-actions-demandees-au-docker-daemon" title="Permalink to this headline">¶</a></h3>
<p>Nous allons lancer un autre dans laquel le <strong>socket</strong> est monté.
Et nous allons écouter les actions demandées sur le <strong>Docker Daemon</strong>. <strong>Même ceux provenant d’autres containers</strong>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>docker container run –name admin -ti -v /var/run/docker.sock:/var/run/docker.sock alpine
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>curl –unix-socket /var/run/docker.sock http://localhost/events
</pre></div>
</div>
</section>
</section>
<section id="limitation-des-ressources">
<h2>3.5 Limitation des ressources<a class="headerlink" href="#limitation-des-ressources" title="Permalink to this headline">¶</a></h2>
<p>Nous avons dit que le lancement d’un <strong>containeur</strong> revient en fait à exécuter un <strong>processeur</strong> , et par défaut, il n’y a pas de limite de consommation des ressources matériels.
Par exemple, Un container pourra utiliser toute la RAM  et impacter tout les autres containeurs qui tournent sur la même machine hôte.</p>
<p>Nous pouvons toutefois imposer des limites à un containeur.</p>
<p>Lançons un containeur avec l’image <code class="docutils literal notranslate"><span class="pre">estesp/hogit</span></code> qui a pour objectif de consommer de la ram.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">run</span> <span class="o">--</span><span class="n">memory</span> <span class="mi">32</span><span class="n">m</span> <span class="n">estesp</span><span class="o">/</span><span class="n">hogit</span>
</pre></div>
</div>
<p>Avec <code class="docutils literal notranslate"><span class="pre">--memory</span> <span class="pre">32m</span></code>, nous avons fixé une limite : quand le processus aura atteint la limite de <code class="docutils literal notranslate"><span class="pre">32M</span></code> de <strong>RAM</strong> consomméecho, il sera tué par <strong>Docker</strong>.</p>
<p>Nous pouvons limiter l’utilisation du <strong>CPU</strong> également.
Lançons un containeur avec l’image <code class="docutils literal notranslate"><span class="pre">progrium/stress</span></code> qui va se charger de stresser les cœurs du <strong>CPU</strong>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>docker container run -it –rm progrium/stress -–cpu 4
</pre></div>
</div>
<p>Ici les <strong>4</strong> cœurs du <strong>CPU</strong> serons utilisés car nous n’avons pas imposé de limite.</p>
<p>Maintenant lançons la même commande avec le flag <code class="docutils literal notranslate"><span class="pre">--cpus</span> <span class="pre">0.5</span></code> pour limiter l’utilisation du <strong>CPU à la moitié d’un cœur</strong>. (<strong>12%</strong> d’utilisation)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>docker container run -it --rm progrium/stress -–cpu 4 –-cpus 0.5
</pre></div>
</div>
<p>En utilisant la valeur du flag : <code class="docutils literal notranslate"><span class="pre">--cpus</span> <span class="pre">2</span></code> , nous limitons l’utilisation à 2 cœurs seulement. (<strong>50%</strong> d’utilisation)</p>
</section>
<section id="les-droits-dans-un-container">
<h2>3.6 Les droits dans un container<a class="headerlink" href="#les-droits-dans-un-container" title="Permalink to this headline">¶</a></h2>
<p>Dans un containeur, s’il n’est pas précisé explicitement, l’utilisateur <code class="docutils literal notranslate"><span class="pre">root</span></code> sera utilisé comme propriétaire.
L’utilisateur <code class="docutils literal notranslate"><span class="pre">root</span></code> du containeur correspond à l’utilisateur <code class="docutils literal notranslate"><span class="pre">root</span></code> de la machine hôte.</p>
<p>Une bonne pratique est d’utiliser un autre utilisateur pour lancer le containeur.</p>
<p>Il y a plusieurs façons de le définir : soit à la création de l’image, soit en utilisant l’option <code class="docutils literal notranslate"><span class="pre">–user</span></code>, soit en changeant l’utilisateur dans le processus du container (<code class="docutils literal notranslate"><span class="pre">gosu</span></code>).</p>
<p>Lançons un container basé sur l’image <strong>Alpine</strong> et exécutons l’instruction sleep 10000.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">run</span> <span class="o">-</span><span class="n">d</span> <span class="n">alpine</span> <span class="n">sleep</span> <span class="mi">10000</span>
</pre></div>
</div>
<p>Nous allons vérifier le <code class="docutils literal notranslate"><span class="pre">owner</span></code> du processus depuis la machine hôte :</p>
<p><strong>Pour LINUX :</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ps</span> <span class="n">aux</span> <span class="o">|</span> <span class="n">grep</span> <span class="n">sleep</span>
</pre></div>
</div>
<p><strong>pour WINDOWS :</strong></p>
<p>Sous Windows, nous n’avons pas accès aux commandes LINUX nativement.
Il faut utiliser les commandes Docker natives pour avoir accès aux informations liées aux processus des containeurs par l’intermédiaire de leur identifiant ou nom et
via la commande <code class="docutils literal notranslate"><span class="pre">top</span></code>.</p>
<p>Récupérez l’identifiant ou le nom du container obtenue avec la commande précédente puis :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">top</span> <span class="o">&lt;</span><span class="n">identifiant</span> <span class="n">ou</span> <span class="n">nom</span> <span class="n">du</span> <span class="n">container</span><span class="o">&gt;</span>
</pre></div>
</div>
<img alt="_images/image74.png" src="_images/image74.png" />
<p>Faisons la même manipulation, mais cette fois avec l’image officielle de <strong>MongoDB</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">run</span> <span class="o">-</span><span class="n">d</span> <span class="n">mongo</span>
</pre></div>
</div>
<img alt="_images/image75.png" src="_images/image75.png" />
<p>On constate que le processus est la propriété d’un <code class="docutils literal notranslate"><span class="pre">owner</span></code> qui posséde un <code class="docutils literal notranslate"><span class="pre">UID</span></code> de <strong>999</strong>.
Nous verrons par la suite comme il est possible de configurer le <code class="docutils literal notranslate"><span class="pre">owner</span></code> d’un processus lors du montage de <strong>container</strong>.</p>
</section>
<section id="des-options-utiles">
<h2>3.6 Des options utiles<a class="headerlink" href="#des-options-utiles" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">--name</span></code> qui permet de donner un nom au container.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">--rm</span></code> pour supprimer le container quand il est stoppé.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">--restart=on-failure</span></code> pour relancer le container en cas d’erreur.</p></li>
</ul>
</div>
</section>
<section id="les-commandes-de-base-avec-docker">
<h2>3.7 Les commandes de base avec Docker<a class="headerlink" href="#les-commandes-de-base-avec-docker" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="o">&lt;</span><span class="n">command</span><span class="o">&gt;</span>
</pre></div>
</div>
<table class="colwidths-given docutils align-default" id="id14">
<caption><span class="caption-text">Les commandes de base de docker container</span><a class="headerlink" href="#id14" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Commande</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>run</p></td>
<td><p>Création d’un container</p></td>
</tr>
<tr class="row-odd"><td><p>ls</p></td>
<td><p>Liste des containers</p></td>
</tr>
<tr class="row-even"><td><p>inspect</p></td>
<td><p>Détails d’un container</p></td>
</tr>
<tr class="row-odd"><td><p>logs</p></td>
<td><p>Visualisation des logs</p></td>
</tr>
<tr class="row-even"><td><p>exec</p></td>
<td><p>Lancement d’un processus dans un container existant</p></td>
</tr>
<tr class="row-odd"><td><p>stop</p></td>
<td><p>Arrêt d’un container</p></td>
</tr>
<tr class="row-even"><td><p>rm</p></td>
<td><p>Suppression d’un container</p></td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><p>La commande <code class="docutils literal notranslate"><span class="pre">ls</span></code> :</p></li>
</ul>
<p>La commande <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">container</span> <span class="pre">ls</span></code> montre les containers qui sont en cours d’execution.</p>
<img alt="_images/image20.png" src="_images/image20.png" />
<p>Pour lister tout les containers actifs et stoppés : <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">container</span> <span class="pre">ls</span> <span class="pre">-a</span></code>.</p>
<img alt="_images/image1.png" src="_images/image1.png" />
<p>Pour lister les identifiants des containers actifs et stoppés : <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">container</span> <span class="pre">ls</span> <span class="pre">-a</span> <span class="pre">-q</span></code>.</p>
<img alt="_images/image2.png" src="_images/image2.png" />
<p>A partir d’un nom ou identifiant d’un container on peut l’inspecter :</p>
<img alt="_images/image3.png" src="_images/image3.png" />
<p>La commande renvoie une multitude d’information de configuration du container.
On peut utiliser des templates (<strong>Go Template</strong>) pour formater les données reçues et même extraire seulement des informations nécessaires :
par exemple : <strong>Obtenir l’IP</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">inspect</span> <span class="o">--</span><span class="nb">format</span> <span class="s1">&#39;{{ .NetworkSettings.IPAddress }}&#39;</span> <span class="n">clever_kilby</span>
</pre></div>
</div>
<ul class="simple">
<li><p>La commande <code class="docutils literal notranslate"><span class="pre">logs</span></code> :</p></li>
</ul>
<p>Cette commande,nous permets de visualiser les logs d’un container , l’option <code class="docutils literal notranslate"><span class="pre">-f</span></code> permet de les lire en temps réel.</p>
<p>Créons un container sous une image <strong>alpine</strong> qui exécutera une commande <code class="docutils literal notranslate"><span class="pre">ping</span> <span class="pre">8.8.8.8</span></code> et qui sera nommé : <strong>ping</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">run</span> <span class="o">--</span><span class="n">name</span> <span class="n">ping</span> <span class="o">-</span><span class="n">d</span> <span class="n">alpine</span> <span class="n">ping</span> <span class="mf">8.8.8.8</span>
</pre></div>
</div>
<p>Puis, écoutons en temps réel les <strong>logs</strong> du container nommé <strong>ping</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">logs</span> <span class="o">-</span><span class="n">f</span> <span class="n">ping</span>
</pre></div>
</div>
<img alt="_images/image4.png" src="_images/image4.png" />
<ul class="simple">
<li><p>La commande <code class="docutils literal notranslate"><span class="pre">exec</span></code> :</p></li>
</ul>
<p>Cette commande permet de lancer un processus dans un container existant pour faire du débug par exemple.
Dans ce cas nous utiliserons les options <code class="docutils literal notranslate"><span class="pre">-t</span></code> et <code class="docutils literal notranslate"><span class="pre">-i</span></code> pour obtenir un  <code class="docutils literal notranslate"><span class="pre">shell</span></code> intéractif.</p>
<p><strong>Exemple</strong> : lançons un container qui attend 100000 secondes, et demandons ensuite d’ouvrir un shell pour lister les processus de ce container.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">run</span> <span class="o">-</span><span class="n">d</span> <span class="o">--</span><span class="n">name</span> <span class="n">debug</span> <span class="n">alpine</span> <span class="n">sleep</span> <span class="mi">100000</span>
</pre></div>
</div>
<p>On lance le container avec l’option <code class="docutils literal notranslate"><span class="pre">-d</span></code> pour le mettre en tâche de fond et récupérer la main sur le terminal et on lui donne le nom <code class="docutils literal notranslate"><span class="pre">debug</span></code> pour le manipuler facilement.</p>
<p>Ensuite nous utilisons la commande <code class="docutils literal notranslate"><span class="pre">exec</span></code> qui injectera dans notre container une commande, à savoir ici, la demande d’ouverture d’un <code class="docutils literal notranslate"><span class="pre">shell</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">exec</span> <span class="o">-</span><span class="n">ti</span> <span class="n">debug</span> <span class="n">sh</span>
</pre></div>
</div>
<img alt="_images/image5.png" src="_images/image5.png" />
<p>Sur la capture d’écran :
Dans le shell, nous avons exécuté la commande <code class="docutils literal notranslate"><span class="pre">ps</span> <span class="pre">aux</span></code>. Qui permet de lister les processus et leur <code class="docutils literal notranslate"><span class="pre">owner</span></code>.
On constact que le processus de <strong>PID 1</strong> , correspond à la commande <code class="docutils literal notranslate"><span class="pre">sleep</span></code>.
Et le processus de PID 15 correspond à notre <code class="docutils literal notranslate"><span class="pre">ps</span> <span class="pre">aux</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Si l’on <code class="docutils literal notranslate"><span class="pre">kill</span></code> le processus de <strong>PID 1</strong>, le container s’arrêtera, car un container n’est actif que tant que son processus de <strong>PID 1</strong> spécifié au lancement est en cours d’exécution.</p>
</div>
<ul class="simple">
<li><p>La commande <code class="docutils literal notranslate"><span class="pre">stop</span></code> :</p></li>
</ul>
<p>Cette commande permet de stopper un ou plusieurs containers.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">stop</span> <span class="o">&lt;</span><span class="n">ID</span><span class="o">&gt;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">stop</span> <span class="o">&lt;</span><span class="n">NAME</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Nous pouvons combiner des commandes !</p>
<p><strong>Rappel :</strong>  Obtenir la liste des containers en cours d’exécution :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">ls</span> <span class="o">-</span><span class="n">q</span>
</pre></div>
</div>
<p>Donc pour stopper les containers en cours d’exécution :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>docker container stop $(docker container ls -q)
</pre></div>
</div>
<p>Les containers stoppés existent toujours :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">ls</span> <span class="o">-</span><span class="n">a</span>
</pre></div>
</div>
<ul class="simple">
<li><p>La commande <code class="docutils literal notranslate"><span class="pre">rm</span></code> :</p></li>
</ul>
<p>Pour supprimer un container.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">rm</span> <span class="o">&lt;</span><span class="n">ID</span><span class="o">&gt;</span>
<span class="n">docker</span> <span class="n">container</span> <span class="n">rm</span> <span class="o">&lt;</span><span class="n">NAME</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Donc, par combinaison de commande, nous pouvons supprimer définitivement un ou plusieurs containers qui sont déjà stoppé.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>docker container rm $(docker container ls -aq)
</pre></div>
</div>
<p>Avec l’option <code class="docutils literal notranslate"><span class="pre">-f</span></code> nous pouvons forcer l’arrêt d’un container et le supprimer dans la foulée.</p>
</section>
<section id="en-pratique">
<h2>3.8 En pratique :<a class="headerlink" href="#en-pratique" title="Permalink to this headline">¶</a></h2>
<p>Lançons quelques containers pour pratiquer, vous devez être en mesure de comprendre maintenant la finalité de ces 3 commandes :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">run</span> <span class="o">-</span><span class="n">d</span> <span class="o">-</span><span class="n">p</span> <span class="mi">80</span><span class="p">:</span><span class="mi">80</span> <span class="o">--</span><span class="n">name</span> <span class="n">www</span> <span class="n">nginx</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">run</span> <span class="o">-</span><span class="n">d</span> <span class="o">--</span><span class="n">name</span> <span class="n">ping</span> <span class="n">alpine</span> <span class="n">ping</span> <span class="mf">8.8.8.8</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">run</span> <span class="n">hello</span><span class="o">-</span><span class="n">world</span>
</pre></div>
</div>
<p>Listons les containers :</p>
<img alt="_images/image6.png" src="_images/image6.png" />
<p>Nous voyons les 2 premiers containers avec le statut <strong>UP</strong>.
Nous ne voyons pas le 3 ieme container pour la simple raison qu’une fois qu’il a effectué son action : <code class="docutils literal notranslate"><span class="pre">echo</span> <span class="pre">hello</span> <span class="pre">world</span></code> , il s’est arrêté automatiquement.
Par contre avec un :
<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">container</span> <span class="pre">ls</span> <span class="pre">-a</span></code> celui-ci est visible.</p>
<img alt="_images/image7.png" src="_images/image7.png" />
<p>Son statut est <strong>exited</strong>, indiquant qu’il n’est pas démarré.</p>
<p>Nous pouvons inspecter les containers et en particulier extraire une information comme l’<strong>adresse IP</strong> de notre serveur web <strong>NGINX</strong> :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">inspect</span> <span class="o">--</span><span class="nb">format</span> <span class="s1">&#39;{{ .NetworkSettings.IPAddress }}&#39;</span> <span class="n">www</span>
</pre></div>
</div>
<img alt="_images/image8.png" src="_images/image8.png" />
<p>Nous pouvons lancer une commande dans un container en cours : par exemple nous voulons lister la liste des processus en cours dans le container <strong>ping</strong> :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">exec</span> <span class="o">-</span><span class="n">ti</span> <span class="n">ping</span> <span class="n">sh</span>
</pre></div>
</div>
<p>Un <code class="docutils literal notranslate"><span class="pre">shell</span></code> est alors disponible, et dedans nous pouvons taper la commande : <code class="docutils literal notranslate"><span class="pre">ps</span> <span class="pre">aux</span></code></p>
<img alt="_images/image9.png" src="_images/image9.png" />
<p>Tapez : <code class="docutils literal notranslate"><span class="pre">exit</span></code> pour sortir du <code class="docutils literal notranslate"><span class="pre">shell</span></code>.</p>
<p>Stoppons les containers : <strong>ping</strong> et <strong>www</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">stop</span> <span class="n">ping</span> <span class="n">www</span>
</pre></div>
</div>
<p>faites ensuite : <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">container</span> <span class="pre">ls</span></code></p>
<blockquote>
<div><p>Que constatez vous ?  Pourquoi ?</p>
</div></blockquote>
<p>Même question avec : <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">container</span> <span class="pre">ls</span> <span class="pre">-a</span></code></p>
<p>Supprimons maintenant les containers créés :</p>
<p><code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">container</span> <span class="pre">rm</span> <span class="pre">$(docker</span> <span class="pre">container</span> <span class="pre">ls</span> <span class="pre">-a</span> <span class="pre">-q)</span></code></p>
</section>
<section id="exercices">
<h2>3.9 Exercices :<a class="headerlink" href="#exercices" title="Permalink to this headline">¶</a></h2>
<section id="exercice-1-hello-from-alpine">
<h3>3.9.1 Exercice 1 : Hello From Alpine<a class="headerlink" href="#exercice-1-hello-from-alpine" title="Permalink to this headline">¶</a></h3>
<p>Le but de ce premier exercice est de lancer des containers basés sur l’image <strong>alpine</strong>.</p>
<ol class="arabic simple">
<li><p>Lancez un container basé sur alpine en lui fournissant la command echo hello</p></li>
<li><p>Quelles sont les étapes effectuées par le docker daemon ?</p></li>
<li><p>Lancez un container basé sur alpine sans lui spécifier de commande. Qu’observez-vous ?</p></li>
</ol>
</section>
<section id="exercice-2-shell-interactif">
<h3>3.9.2 Exercice 2 : Shell intéractif<a class="headerlink" href="#exercice-2-shell-interactif" title="Permalink to this headline">¶</a></h3>
<p>Le but de cet exercice est lancer des containers en mode <strong>intéractif</strong>.</p>
<ol class="arabic simple">
<li><p>Lancez un container basé sur alpine en mode <strong>interactif</strong> sans lui spécifier de commande</p></li>
<li><p>Que s’est-il passé ?</p></li>
<li><p>Quelle est la commande par défaut d’un container basé sur <strong>alpine</strong> ?</p></li>
<li><p>Naviguez dans le <strong>système de fichiers</strong></p></li>
<li><p>Utilisez le gestionnaire de package d’alpine (<code class="docutils literal notranslate"><span class="pre">apk</span></code>) pour ajouter un package :  <code class="docutils literal notranslate"><span class="pre">apk</span> <span class="pre">update</span></code> et <code class="docutils literal notranslate"><span class="pre">apk</span> <span class="pre">add</span> <span class="pre">curl</span></code>.</p></li>
</ol>
</section>
<section id="exercice-3-foreground-background">
<h3>3.9.3 Exercice 3 : foreground / background<a class="headerlink" href="#exercice-3-foreground-background" title="Permalink to this headline">¶</a></h3>
<p>Le but de cet exercice est de créer des containers en <strong>foreground</strong> et en <strong>background</strong>.</p>
<ol class="arabic simple">
<li><p>Lancez un container basé sur alpine en lui spécifiant la commande <code class="docutils literal notranslate"><span class="pre">ping</span> <span class="pre">8.8.8.8</span></code>.</p></li>
<li><p>Arrêter le container avec <code class="docutils literal notranslate"><span class="pre">CTRL-C</span></code></p></li>
</ol>
<p>Le container est t-il toujours en cours d’exécution ?</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Vous pouvez utiliser la commande <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">ps</span></code> que nous détaillerons prochainement, et qui permet de lister les containers qui tournent sur la machine.</p>
</div>
<ol class="arabic simple">
<li><p>Lancez un container en mode interactif en lui spécifiant la commande <code class="docutils literal notranslate"><span class="pre">ping</span> <span class="pre">8.8.8.8</span></code>.</p></li>
<li><p>Arrêter le container avec <code class="docutils literal notranslate"><span class="pre">CTRL-P</span> <span class="pre">CTRL-Q</span></code></p></li>
</ol>
<p>Le container est t-il toujours en cours d’exécution ?</p>
<ol class="arabic simple">
<li><p>Lancez un container en <strong>background</strong>, toujours en lui spécifiant la commande <code class="docutils literal notranslate"><span class="pre">ping</span> <span class="pre">8.8.8.8</span></code>.</p></li>
</ol>
<p>Le container est t-il toujours en cours d’exécution ?</p>
</section>
<section id="exercice-4-publication-de-port">
<h3>3.9.4 Exercice 4 : Publication de port<a class="headerlink" href="#exercice-4-publication-de-port" title="Permalink to this headline">¶</a></h3>
<p>Le but de cet exercice est de créer un container <strong>en exposant un port</strong> sur la machine <strong>hôte</strong>.</p>
<ol class="arabic simple">
<li><p>Lancez un container basé sur <code class="docutils literal notranslate"><span class="pre">nginx</span></code> et publiez le <code class="docutils literal notranslate"><span class="pre">port</span> <span class="pre">80</span></code> du container sur le <code class="docutils literal notranslate"><span class="pre">port</span> <span class="pre">8080</span></code> de l’hôte.</p></li>
<li><p>Vérifiez depuis votre navigateur que la page par défaut de <code class="docutils literal notranslate"><span class="pre">nginx</span></code> est servie sur <code class="docutils literal notranslate"><span class="pre">http://localhost:8080</span></code>.</p></li>
<li><p>Lancez un second container en publiant le même port.</p></li>
</ol>
<p>Qu’observez-vous ?</p>
</section>
<section id="exercice-5-liste-des-containers">
<h3>3.9.5 Exercice 5 : Liste des containers<a class="headerlink" href="#exercice-5-liste-des-containers" title="Permalink to this headline">¶</a></h3>
<p>Le but de cet exercice est de montrer les différentes options pour lister les containers du système.</p>
<ol class="arabic simple">
<li><p>Listez les containers en cours d’exécution.</p></li>
</ol>
<p>Est ce que tous les containers que vous avez créés sont listés ?</p>
<ol class="arabic simple">
<li><p>Utilisez l’option <code class="docutils literal notranslate"><span class="pre">-a</span></code> pour voir également les containers qui ont été stoppés.</p></li>
<li><p>Utilisez l’option <code class="docutils literal notranslate"><span class="pre">-q</span></code> pour ne lister que les IDs des containers (en cours d’exécution ou stoppés).</p></li>
</ol>
</section>
<section id="exercice-6-inspection-d-un-container">
<h3>3.9.6 Exercice 6 : Inspection d’un container<a class="headerlink" href="#exercice-6-inspection-d-un-container" title="Permalink to this headline">¶</a></h3>
<p>Le but de cet exercice est l’inspection d’un container.</p>
<ol class="arabic simple">
<li><p>Lancez, en <strong>background</strong>, un nouveau container basé sur <strong>nginx</strong> en publiant le <strong>port 80</strong> du container sur le <strong>port 3000</strong> de la machine host.</p></li>
</ol>
<p>Notez l’identifiant du container retourné par la commande précédente.</p>
<ol class="arabic simple">
<li><p>Inspectez le container en utilisant son identifiant.</p></li>
<li><p>En utilisant le <strong>format Go template</strong>, récupérez le nom et l’<strong>IP</strong> du container.</p></li>
<li><p>Manipuler les <strong>Go template</strong> pour récupérer d’autres information.</p></li>
</ol>
</section>
<section id="exercice-7-exec-dans-un-container">
<h3>3.9.7 Exercice 7 : exec dans un container<a class="headerlink" href="#exercice-7-exec-dans-un-container" title="Permalink to this headline">¶</a></h3>
<p>Le but de cet exercice est de montrer comment lancer un processus dans un container existant.</p>
<ol class="arabic simple">
<li><p>Lancez un container en background, basé sur l’image alpine. Spécifiez la commande <code class="docutils literal notranslate"><span class="pre">ping</span> <span class="pre">8.8.8.8</span></code> et le nom ping avec l’option <code class="docutils literal notranslate"><span class="pre">--name</span></code>.</p></li>
<li><p>Observez les logs du container en utilisant l’ID retourné par la commande précédente ou bien le nom du container.</p></li>
</ol>
<p>Quittez la commande de logs avec <code class="docutils literal notranslate"><span class="pre">CTRL-C</span></code>.</p>
<ol class="arabic simple">
<li><p>Lancez un shell <code class="docutils literal notranslate"><span class="pre">sh</span></code>, en mode <strong>interactif</strong>, dans le container précédent.</p></li>
<li><p>Listez les processus du container.</p></li>
</ol>
<p>Qu’observez vous par rapport aux identifiants des processus ?</p>
</section>
<section id="exercice-8-cleanup">
<h3>3.9.8 Exercice 8 : cleanup<a class="headerlink" href="#exercice-8-cleanup" title="Permalink to this headline">¶</a></h3>
<p>Le but de cet exercice est de stopper et de supprimer les containers existants.</p>
<ol class="arabic simple">
<li><p>Listez tous les containers (<strong>actifs</strong> et <strong>inactifs</strong>)</p></li>
<li><p>Stoppez tous les containers encore actifs en fournissant la liste des IDs à la commande <code class="docutils literal notranslate"><span class="pre">stop</span></code>.</p></li>
<li><p>Vérifiez qu’il n’y a plus de containers actifs.</p></li>
<li><p>Listez les containers arrêtés.</p></li>
<li><p>Supprimez tous les containers.</p></li>
<li><p>Vérifiez qu’il n’y a plus de containers.</p></li>
</ol>
</section>
</section>
<section id="en-resume">
<h2>3.10 En résumé<a class="headerlink" href="#en-resume" title="Permalink to this headline">¶</a></h2>
<p>Nous avons commencé à jouer avec les containers et vu les commandes les plus utilisées pour la gestion du cycle de vie des containers
(<code class="docutils literal notranslate"><span class="pre">run</span></code>, <code class="docutils literal notranslate"><span class="pre">exec</span></code>, <code class="docutils literal notranslate"><span class="pre">ls</span></code>, <code class="docutils literal notranslate"><span class="pre">rm</span></code>, <code class="docutils literal notranslate"><span class="pre">inspect</span></code>). Nous les utiliserons souvent dans la suite du cours.</p>
<p>C’est parfois utile d’avoir un <code class="docutils literal notranslate"><span class="pre">Shell</span></code> directement sur la machine hôte.
C’est-à-dire la machine sur laquelle le <code class="docutils literal notranslate"><span class="pre">Docker</span> <span class="pre">Daemon</span></code> tourne.
Si l’on est sur <code class="docutils literal notranslate"><span class="pre">linux</span></code>, le client et le <code class="docutils literal notranslate"><span class="pre">daemon</span></code> tournent sur la <strong>même machine.</strong>
Par contre le <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">daemon</span></code> va tourner sur une <strong>machine virtuelle</strong> sous Windows alors que le client sera lui sur une machine locale.</p>
</section>
</section>
<section id="les-images-docker">
<h1>4.0 Les images Docker<a class="headerlink" href="#les-images-docker" title="Permalink to this headline">¶</a></h1>
<p>Nous allons parler des images <strong>Docker</strong>.
Une image est un système de fichier qui contient une application et l’ensemble des éléments nécessaires pour la faire tourner.
On peut voir une image comme étant un <strong>template</strong> permettant la création d’un container.
L’image est portable sur n’importe quel environnement où tourne <strong>Docker</strong> et est composée de <strong>couches</strong> (<strong>layers</strong>) qui peuvent être réutilisé par d’autres images.
On distribue une image via un <strong>registry</strong> ( ex : Docker Hub)</p>
<p>Contenu d’une image :</p>
<img alt="_images/image10.png" src="_images/image10.png" />
<p>La construction du fichier image, se fait dans l’ordre inverse du contenu d’une image que l’on vient de lister.</p>
<p>On part d’un OS de base qui va ajouter une ou plusieurs couches comme le système de fichiers.
A cet OS on va ajouter une ou plusieurs couches liées à l’environnement de notre application puis de la même façon les dépendances et le code applicatifs.</p>
<p>Et l’ensemble de ses couches forment l’image.</p>
<img alt="_images/image34.png" src="_images/image34.png" />
<section id="union-filesystem">
<h2>4.1 Union Filesystem<a class="headerlink" href="#union-filesystem" title="Permalink to this headline">¶</a></h2>
<p>Une image est donc constituée d’un ensemble de <strong>layers</strong> ou <strong>couches</strong> et chacune d’elles est en <strong>lectures seules</strong>. Et c’est le rôle du <strong>storage/graph driver</strong> de constituer le système de fichier global de l’instance du container.</p>
<p>Le <strong>Graph driver</strong> ajoute en plus une couche qui est en <strong>lecture/écriture</strong> pour permettre au processus de modifier le filesystem sans que les modifications ne soient persistées dans les layers de l’image.
Il existe plusieurs <strong>filesystem</strong> et le choix du système dépend principalement du <strong>filesystem hôte</strong>.
Par default, toutes les layers sont installées dans le répertoire <code class="docutils literal notranslate"><span class="pre">/var/lib/docker</span></code> sur la machine hôte et c’est à cette endroit que sont stockées toutes les layers des images.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Sur windows 10, docker s’exécute sur une VM.
Ressources à consulter pour comprendre comment Docker fonction sous Windows :</p>
<ol class="arabic simple">
<li><p><a class="reference external" href="https://docs.docker.com/desktop/windows/">https://docs.docker.com/desktop/windows/</a></p></li>
<li><p><a class="reference external" href="https://forums.docker.com/t/the-location-of-images-in-docker-for-windows/19647">https://forums.docker.com/t/the-location-of-images-in-docker-for-windows/19647</a></p></li>
</ol>
</div>
<p>Pour accèder à ce dossier sous Windows, il faut alors créer un container et le lier avec Docker :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">run</span> <span class="o">-</span><span class="n">it</span> <span class="o">--</span><span class="n">privileged</span> <span class="o">--</span><span class="n">pid</span><span class="o">=</span><span class="n">host</span> <span class="n">debian</span> <span class="n">nsenter</span> <span class="o">-</span><span class="n">t</span> <span class="mi">1</span> <span class="o">-</span><span class="n">m</span> <span class="o">-</span><span class="n">u</span> <span class="o">-</span><span class="n">i</span> <span class="n">sh</span>
</pre></div>
</div>
<p>Nous pouvons alors lister le dossier <code class="docutils literal notranslate"><span class="pre">/var/lib/docker</span></code> dans le shell.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ls</span> <span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">docker</span>
</pre></div>
</div>
<p>Il est possible de modifier des fichiers qui sont apportés par une layer ; cela s’appelle : <strong>copy-On-Write</strong>.
Le fichier original est alors copier dans la layer qui est en <strong>lecture / écriture</strong> et la modification peut être <strong>persistée</strong>.</p>
<img alt="_images/image35.png" src="_images/image35.png" />
</section>
<section id="id1">
<h2>4.2 Exercices<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<section id="exercice-1-container-s-layer">
<h3>4.2.1 Exercice 1 : Container’s layer<a class="headerlink" href="#exercice-1-container-s-layer" title="Permalink to this headline">¶</a></h3>
<p>La layer d’un container, est la layer <strong>read-write</strong> créé lorsqu’un container est lancé.
C’est la layer dans laquelle tous les changements effectués dans le container sont sauvegardés.
Cette layer est supprimée avec le container et ne doit donc pas être utilisée comme un stockage persistant.</p>
<p><strong>Lancement d’un container</strong></p>
<p>Utilisez la commande suivante pour lancer un <strong>shell intéractif</strong> dans un container basé sur l’image <code class="docutils literal notranslate"><span class="pre">ubuntu</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">run</span> <span class="o">-</span><span class="n">ti</span> <span class="n">ubuntu</span>
</pre></div>
</div>
<p><strong>Installation d’un package</strong></p>
<p><strong>figlet</strong> est un package qui prend un texte en entrée et le formatte de façon amusante.
Par défaut ce package n’est pas disponible dans l’image ubuntu.</p>
<p>Vérifiez le avec la commande suivante:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">figlet</span>
</pre></div>
</div>
<p>La commande devrait donner le résultat suivant :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bash</span><span class="p">:</span> <span class="n">figlet</span><span class="p">:</span> <span class="n">command</span> <span class="ow">not</span> <span class="n">found</span>
</pre></div>
</div>
<p>Installez le package <strong>figlet</strong> avec les commandes suivantes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">update</span> <span class="o">-</span><span class="n">y</span>
<span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">install</span> <span class="n">figlet</span>
</pre></div>
</div>
<p>Vérifiez que le binaire fonctionne :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">figlet</span> <span class="n">Hola</span>
</pre></div>
</div>
<p>Ce qui devrait donner le résultat suivant</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>| | | | ___ | | __ _
| |_| |/ _ \| |/ _` |
|  _  | (_) | | (_| |
|_| |_|\___/|_|\__,_|
</pre></div>
</div>
<p>Sortez du container.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">exit</span>
</pre></div>
</div>
<p><strong>Lancement d’un nouveau container</strong></p>
<p>Lancez un nouveau container basé sur <code class="docutils literal notranslate"><span class="pre">ubuntu</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">run</span> <span class="o">-</span><span class="n">ti</span> <span class="n">ubuntu</span>
</pre></div>
</div>
<p>Vérifiez si le package figlet est présent :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">figlet</span>
</pre></div>
</div>
<p>Vous devriez obtenir l’erreur suivante:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bash</span><span class="p">:</span> <span class="n">figlet</span><span class="p">:</span> <span class="n">command</span> <span class="ow">not</span> <span class="n">found</span>
</pre></div>
</div>
<p>Comment expliquez-vous ce résultat ?
Chaque container lancé à partir de l’image <strong>ubuntu</strong> est différent des autres.
Le second container est différent de celui dans lequel <strong>figlet</strong> a été installé.
Chacun correspond à une instance de l’image ubuntu et a sa propre <strong>layer</strong>, ajoutée au dessus des layers de l’image, et dans laquelle tous les changements effectués dans le container sont sauvegardés.</p>
<p>Sortez du container.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">exit</span>
</pre></div>
</div>
<p><strong>Redémarrage du container</strong></p>
<p>Listez les containers (en exécution ou non) sur la machine hôte.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">ls</span> <span class="o">-</span><span class="n">a</span>
</pre></div>
</div>
<p>Depuis cette liste, récuperez l’ID du container dans lequel le package figlet a été installé et redémarrez le avec la commande suivante.</p>
<p><strong>Note:</strong> la commande <code class="docutils literal notranslate"><span class="pre">start</span></code> permet de démarrer un container se trouvant dans l’état <code class="docutils literal notranslate"><span class="pre">Exited</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">start</span> <span class="o">&lt;</span><span class="n">CONTAINER_ID</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Lancez un <strong>shell intéractif</strong> dans ce container en utilisant la commande <code class="docutils literal notranslate"><span class="pre">exec</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">exec</span> <span class="o">-</span><span class="n">ti</span> <span class="o">&lt;</span><span class="n">CONTAINER_ID</span><span class="o">&gt;</span> <span class="n">bash</span>
</pre></div>
</div>
<p>Vérifez que <strong>figlet</strong> est présent dans ce container.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">figlet</span> <span class="n">Hola</span>
</pre></div>
</div>
<p>Résultat :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>| | | | ___ | | __ _
| |_| |/ _ \| |/ _` |
|  _  | (_) | | (_| |
|_| |_|\___/|_|\__,_|
</pre></div>
</div>
<p>Vous pouvez maintenant sortir du container.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">exit</span>
</pre></div>
</div>
<p><strong>Nettoyage</strong></p>
<p>Listez les containers (en exécution ou non) sur la machine hôte</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">ls</span> <span class="o">-</span><span class="n">a</span>
</pre></div>
</div>
<p>Pour supprimer tous les containers, nous pouvons utiliser les commandes <code class="docutils literal notranslate"><span class="pre">rm</span></code> et <code class="docutils literal notranslate"><span class="pre">ls</span> <span class="pre">-aq</span></code> conjointement. Nous ajoutons l’option <code class="docutils literal notranslate"><span class="pre">-f</span></code> afin de forcer la suppression des containers encore en exécution. Il faudrait sinon arrêter les containers et les supprimer.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>docker container rm -f $(docker container ls -aq)
</pre></div>
</div>
<p>Tous les containers ont été supprimés, vérifiez le une nouvelle fois avec la commande suivante:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">ls</span> <span class="o">-</span><span class="n">a</span>
</pre></div>
</div>
</section>
</section>
<section id="dockerfile">
<h2>4.3 DockerFile<a class="headerlink" href="#dockerfile" title="Permalink to this headline">¶</a></h2>
<p>Le <strong>DockerFile</strong> est un fichier texte qui est utilisé pour la construction d’<strong>une image DOCKER</strong>.
Il contient des instructions pour la construction du système de fichier d’une image.
Nous allons partir d’un fichier de base qui sera enrichie par notre application et l’ensemble de ses dépendances.</p>
<ul class="simple">
<li><p>Exemple d’un <strong>Docker File</strong> dans laquelle est packagée une application <strong>NODEJS</strong>.</p></li>
</ul>
<img alt="_images/image36.png" src="_images/image36.png" />
<p>Avec l’instruction <strong>FROM</strong> nous définissons une image de base dans laquelle l’application <strong>NODEJS</strong> sera packagée.</p>
<ul class="simple">
<li><p><strong>COPY</strong> qui permet d’ajouter la liste des dépendances.</p></li>
<li><p><strong>RUN</strong> permet de définir la commande d’installation des dépendances.</p></li>
<li><p><strong>EXPOSE</strong> défini le port utilisé par l’application.</p></li>
<li><p><strong>WORKDIR</strong> nous positionnes dans le répertoire de travail.</p></li>
<li><p><strong>CMD</strong> défini la commande à lancer lorsqu’un container sera lancer à partir de cette image.</p></li>
</ul>
<p>Voici la liste des principales instructions à utiliser dans un <strong>DockerFile</strong>.</p>
<img alt="_images/image37.png" src="_images/image37.png" />
<p><strong>L’instruction FROM.</strong></p>
<p>Il s’agit de la première instruction dans un DOckerFile. Elle permet de spécifier l’image à partir de laquelle nous allons créer une nouvelle image.
On peut partir d’une image d’un OS, ou d’une image contenant déjà des applications comme un serveur web, ou un environnement d’exécution enveloppé dans une image contenant un OS de base.</p>
<p>Nous pouvons utiliser également une image particulière qui s’appelle <strong>SCRATCH</strong>, c’est une image au sens <strong>DOCKER</strong> même si elle est vide, et peut etre utilisé par example dans une application écrite en langage GO qui n’a pas besoin d’être packagé dans un système de fichier.</p>
<p><strong>L’instruction ENV.</strong></p>
<p>Cette instruction nous permet de définir des variables d’environnement. Et pourront être utilisée dans les instructions suivantes lors de la construction de l’image. On les retrouvera dans l’environnement des containers lancés à partir de cette image.</p>
<img alt="_images/image38.png" src="_images/image38.png" />
<p>Dans cet exemple, nous construisons une image basée sur NGINX et on défini une variable <code class="docutils literal notranslate"><span class="pre">path</span></code> que l’on pourra utiliser dans les instructions suivantes : <strong>WORKDIR</strong> et <strong>COPY</strong>.</p>
<p><strong>L’instruction COPY / ADD.</strong></p>
<p>Permet de copier des ressources locales vers le système de fichier de l’image que l’on créé.</p>
<p>Et cela engendre la création d’une nouvelle layer pour l’image.</p>
<p>Avec l’option <code class="docutils literal notranslate"><span class="pre">–chown</span></code> on peut définir les droits sur ces fichiers qu’auront les utilisateurs de l’image.</p>
<p>ADD permet des actions supplémentaires comme récupérer des ressources à partir d’une URL.
Ou de Dézipper des fichiers.</p>
<p>Il est préférable d’utiliser <strong>COPY</strong> par rapport à <strong>ADD</strong> car l’on maitrise davantage comment la copie est faite.</p>
<p><strong>L’instruction RUN.</strong></p>
<p><strong>RUN</strong> est une instruction qui va engendrer la construction d’une nouvelle <strong>layer</strong> pour l’image.</p>
<p>Elle permet d’exécuter une commande dans le système de fichier de l’image comme l’installation d’un package.
Il y a 2 formats pour définir la commande.
Le format <strong>SHELL</strong> qui va lancer la commande dans le contexte d’un <strong>shell</strong>.
Et le format <strong>Exec</strong> qui va définir la commande comme une liste de <strong>string</strong> et qui n’est pas lancée dans le contexte d’un <strong>shell</strong>.</p>
<img alt="_images/image39.png" src="_images/image39.png" />
<p><strong>L’instruction EXPOSE.</strong></p>
<p>Permet de spécifier les ports sur lesquels l’application écoute au lancement du container. Mais cela peut être modifié par l’option : <code class="docutils literal notranslate"><span class="pre">-p</span></code> lors de la création du container.
Nous pouvons utiliser aussi un mapping comme vu précédemment : <code class="docutils literal notranslate"><span class="pre">-p</span> <span class="pre">HOST_PORT:CONTAINER_PORT</span></code>.</p>
<p>On peut aussi utiliser l’option <code class="docutils literal notranslate"><span class="pre">P</span></code> dans ce cas le démon <strong>DOCKER</strong> va publier l’ensemble des ports en attribuant à chacun un port de la machine hôte.</p>
<img alt="_images/image40.png" src="_images/image40.png" />
<p><strong>L’instruction VOLUME.</strong></p>
<p>Permet de définir un répertoire dont les données sont découplées du cycle de vie du container.
Les fichiers ne seront pas stockés dans la layer <strong>lecture/écriture</strong> du container mais dans le système de fichier de la machine hôte. Et si le container est supprimé, les données de ce répertoire seront toujours là.</p>
<p>Si on reprend l’exemple du <strong>dockerfile</strong> de <strong>MongoDB</strong>.</p>
<img alt="_images/image41.png" src="_images/image41.png" />
<p>L’instruction <em>VOLUME</em> est utilisée pour créer 2 volumes. Au lancement de cette image, deux répertoires seront créés sur la machine hôte.</p>
<p><strong>L’instruction USER.</strong></p>
<p>Si on ne définit pas l’utilisateur, par défaut se sera <code class="docutils literal notranslate"><span class="pre">ROOT</span></code> qui sera utilisé. Ce qui pose des problèmes de sécurité évident.</p>
<p><strong>L’instruction HEALTHCHECK.</strong></p>
<p>Vérifie l’état de santé du processus qui tourne dans un container. On peut définir des options comme la fréquence d’inspection.</p>
<img alt="_images/image42.png" src="_images/image42.png" />
<p><strong>L’instruction ENTRYPOINT / CMD.</strong></p>
<p>Spécifie la commande qui sera exécuté lorsque l’on lancera un container basé sur cette image.
Les instruction <strong>CMD</strong> et <strong>ENTRYPOINT</strong> sont les dernières instructions du fichier <strong>DOCKERFILE</strong>.</p>
<p>On précise souvent le binaire de l’application dans <strong>ENTRYPOINT</strong> et les paramètres dans CMD.</p>
<p>La commande alors exécuté correspondra à la concaténation de <strong>ENTRYPOINT</strong> et <strong>CMD</strong>.</p>
<p>On peut modifier ses paramètres au lancement du container si besoin avec l’annotation <strong>Shell</strong> ou <strong>Exec</strong> vu précédemment.</p>
<img alt="_images/image43.png" src="_images/image43.png" />
</section>
<section id="creation-dimages">
<h2>4.3 Création d’images<a class="headerlink" href="#creation-dimages" title="Permalink to this headline">¶</a></h2>
<p>Il est temps maintenant de créer notre image.
Dans un premier temps il faut : créer un fichier <strong>DockerFile</strong> qui contiendra les instructions nécessaires.
Ensuite il faut utiliser la commande :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">image</span> <span class="n">builde</span> <span class="p">[</span><span class="n">OPTIONS</span><span class="p">]</span> <span class="n">PATH</span> <span class="o">|</span> <span class="n">URL</span> <span class="o">|</span> <span class="o">-</span>
</pre></div>
</div>
<p>Des options courantes :</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-f</span></code> : spécifie le fichier à utiliser pour la construction (<strong>DockerFile</strong> par défaut)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">--tag</span> <span class="pre">/</span> <span class="pre">-t</span></code> : spécifie le nom de l’image ([registry/]user/repository :tag)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">--label</span></code> : ajout de métadonnées à l’image.</p></li>
</ul>
</section>
<section id="mise-en-pratique">
<h2>4.4 Mise en pratique<a class="headerlink" href="#mise-en-pratique" title="Permalink to this headline">¶</a></h2>
<p>Nous allons créer une simple application <strong>NODEJS</strong> qui renverra la date et l’heure.
Tout l’environnement nécessaire à l’exécution de ce script sera intégré dans une image que nous allons créer.</p>
<p>Dans un dossier, créez le fichier <code class="docutils literal notranslate"><span class="pre">index.js</span></code>:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">express</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;express&#39;</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">util</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;util&#39;</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">app</span> <span class="o">=</span> <span class="nx">express</span><span class="p">();</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">setHeader</span><span class="p">(</span><span class="s1">&#39;Content-Type&#39;</span><span class="p">,</span> <span class="s1">&#39;text/plain&#39;</span><span class="p">);</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">end</span><span class="p">(</span><span class="nx">util</span><span class="p">.</span><span class="nx">format</span><span class="p">(</span><span class="s1">&#39;%s - %s\n&#39;</span><span class="p">,</span> <span class="ow">new</span> <span class="nb">Date</span><span class="p">(),</span> <span class="s1">&#39;Got Request&#39;</span><span class="p">));</span>
<span class="p">});</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">PORT</span> <span class="o">||</span> <span class="mf">8080</span><span class="p">);</span>
</pre></div>
</div>
<p>Puis créez le fichier <code class="docutils literal notranslate"><span class="pre">package.js</span></code> dans le même dossier :</p>
<div class="highlight-JSON notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;testnode&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="nt">&quot;version&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;0.0.1&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="nt">&quot;main&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;index.js&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="nt">&quot;scripts&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nt">&quot;start&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;node index.js&quot;</span><span class="w"></span>
<span class="w">  </span><span class="p">},</span><span class="w"></span>
<span class="w">  </span><span class="nt">&quot;dependencies&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nt">&quot;express&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;^4.14.0&quot;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Dans une console, placez vous dans le dossier dans lequel vous avez déposé les fichiers et tapez :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">npm</span> <span class="n">install</span>
</pre></div>
</div>
<p>puis</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">npm</span> <span class="n">start</span>
</pre></div>
</div>
<p>Ouvrez un navigateur à l’adresse : <a class="reference external" href="http://localhost:8080">http://localhost:8080</a></p>
<p>Si tout se passe comme prévu alors vous dévriez avoir ceci :</p>
<img alt="_images/image33.png" src="_images/image33.png" />
<p>Notre application fonctionne, mais cela est lourd pour l’utilisateur :</p>
<ol class="arabic simple">
<li><p>Il doit avoir NODEJS d’installé sur sa machine.</p></li>
<li><p>Il doit installer les dépendances du projet, ici <code class="docutils literal notranslate"><span class="pre">express</span></code>.</p></li>
<li><p>Il doit lancer le serveur Nodejs.</p></li>
</ol>
<p>Il faudrait donc créer une image réalisant ces étapes !!</p>
<p>Nous allons créer un <strong>DockerFile</strong>.</p>
<p>Il nous faut trouver une image de base sur : <a class="reference external" href="https://hub.docker.com/search?type=image">Docker Hub</a></p>
<p><strong>Cochez</strong> : « <strong>Official Images</strong> » pour n’avoir que des images officielles.
Nous voyons que nous avons une multitude de possibilité pour concevoir notre image.</p>
<img alt="_images/image23.png" src="_images/image23.png" />
<p>Nous pouvons partir sur une image <strong>LINUX</strong> : <strong>UBUNTU</strong>, <strong>ALPINE</strong> …Etc mais aussi une image où le runtime <strong>NODEJS</strong> est déjà packagé.
C’est ce que nous allons choisir.</p>
<img alt="_images/image24.png" src="_images/image24.png" />
<p>En cliquant dessus, sélectionnez l’onglet <strong>TAGS</strong>.</p>
<img alt="_images/image25.png" src="_images/image25.png" />
<p>Et dans la liste, nous allons nous intéresser à une version de <strong>NODEJS</strong> sous Alpine3.15.</p>
<img alt="_images/image26.png" src="_images/image26.png" />
<p>Et conservons en mémoire le tag de cette version de node : current-alpine3.15</p>
<p>Maintenant dans le dossier contenant notre application, créons un fichier : <strong>Dockerfile</strong>. Sans extension.</p>
<p><strong>Fichier : Dockerfile</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Nous renseignons dans l&#39;instruction FROM le Tag de notre image qui servira de base à notre application</span>
<span class="n">FROM</span> <span class="n">node</span><span class="p">:</span><span class="n">current</span><span class="o">-</span><span class="n">alpine3</span><span class="mf">.15</span>

<span class="c1"># Nous allons copier nos fichiers sources du répertoire courant du fichier Dockerfile dans le repertoire /app/.</span>
<span class="c1"># C&#39;est un répertoire qui sera créé dans l&#39;image lorsque l&#39;on va faire le build</span>
<span class="n">COPY</span> <span class="o">.</span> <span class="o">/</span><span class="n">app</span><span class="o">/</span>
<span class="n">RUN</span> <span class="n">cd</span> <span class="o">/</span><span class="n">app</span> <span class="o">&amp;&amp;</span> <span class="n">npm</span> <span class="n">install</span>
<span class="n">EXPOSE</span> <span class="mi">8080</span>
<span class="n">WORKDIR</span> <span class="o">/</span><span class="n">app</span>
<span class="n">CMD</span> <span class="p">[</span><span class="s2">&quot;npm&quot;</span><span class="p">,</span> <span class="s2">&quot;start&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>A partir de ce <strong>Dockerfile</strong>, nous allons pouvoir créer une <strong>image</strong>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">image</span> <span class="n">build</span> <span class="o">-</span><span class="n">t</span> <span class="n">appbts</span><span class="p">:</span><span class="mf">0.1</span> <span class="o">.</span>
</pre></div>
</div>
<img alt="_images/image27.png" src="_images/image27.png" />
<p>Nous voyons que pour chaque instruction nous avons une étape.</p>
<p>Si nous allons dans <strong>Docker Desktop</strong> , onglet « <strong>Images</strong> » :</p>
<img alt="_images/image28.png" src="_images/image28.png" />
<p>Nous voyons notre image, avec son nom et son numéro de version.
Nous pouvons maintenant créer un containeur avec notre application,
en précisant que nous utiliserons le <code class="docutils literal notranslate"><span class="pre">port</span> <span class="pre">8080</span></code> du container sur le <code class="docutils literal notranslate"><span class="pre">port</span> <span class="pre">8080</span></code> de ma machine hôte.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">run</span> <span class="o">-</span><span class="n">p</span> <span class="mi">8080</span><span class="p">:</span><span class="mi">8080</span> <span class="n">appbts</span><span class="p">:</span><span class="mf">0.1</span>
</pre></div>
</div>
<p>Et je peux maintenant utiliser mon navigateur à l’adresse : <a class="reference external" href="http://localhost:8080">http://localhost:8080</a></p>
</section>
<section id="exercices-creation-dimages">
<h2>4.5 Exercices : Création d’images<a class="headerlink" href="#exercices-creation-dimages" title="Permalink to this headline">¶</a></h2>
<section id="exercice-1-creation-dune-image-a-partir-dun-container">
<h3>4.5.1 Exercice 1 : Création d’une image à partir d’un container<a class="headerlink" href="#exercice-1-creation-dune-image-a-partir-dun-container" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li><p>Lancez une container basé sur une image <strong>alpine</strong>, en mode <strong>interactif</strong>, et en lui donnant le nom <code class="docutils literal notranslate"><span class="pre">c1</span></code>.</p></li>
<li><p>Lancez la commande <code class="docutils literal notranslate"><span class="pre">curl</span> <span class="pre">google.com</span></code>.</p></li>
</ol>
<p>Qu’observez-vous ?</p>
<ol class="arabic simple">
<li><p>Installez <code class="docutils literal notranslate"><span class="pre">curl</span></code> à l’aide du gestionnaire de package <code class="docutils literal notranslate"><span class="pre">apk</span></code>.</p></li>
<li><p>Quittez le container avec <code class="docutils literal notranslate"><span class="pre">CTRL-P</span> <span class="pre">CTRL-Q</span></code> (pour ne pas killer le processus de <strong>PID 1</strong>).</p></li>
<li><p>Créez une image, nommée <code class="docutils literal notranslate"><span class="pre">curly</span></code>, à partir du container <code class="docutils literal notranslate"><span class="pre">c1</span></code>.</p></li>
</ol>
<p>Utilisez pour cela la commande <code class="docutils literal notranslate"><span class="pre">commit</span></code> (<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">commit</span> <span class="pre">--help</span></code> pour voir le fonctionnment de cette commande).</p>
<ol class="arabic simple">
<li><p>Lancez un <code class="docutils literal notranslate"><span class="pre">shell</span></code> intéractif dans un container basée sur l’image <code class="docutils literal notranslate"><span class="pre">curly</span></code> et vérifiez que <code class="docutils literal notranslate"><span class="pre">curl</span></code> est présent.</p></li>
</ol>
</section>
<section id="exercice-2-dockerizez-un-serveur-web-simple">
<h3>4.5.2 Exercice 2 : Dockerizez un serveur web simple<a class="headerlink" href="#exercice-2-dockerizez-un-serveur-web-simple" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li><p>Créer un nouveau répertoire et développez un serveur <strong>HTTP</strong> qui expose le endpoint <code class="docutils literal notranslate"><span class="pre">/ping</span></code> sur le <strong>port 80</strong> et répond par <strong>PONG</strong>. Inspirez vous de l’exemple du cours ci-dessus.</p></li>
<li><p>Dans le même répertoire, créez le fichier <strong>Dockerfile</strong> qui servira à construire l’image de l’application. Ce fichier devra décrire les actions suivantes :</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>spécification d’une image de base.</p></li>
<li><p>installation du runtime correspondant au langage choisi.</p></li>
<li><p>installation des dépendances de l’application.</p></li>
<li><p>copie du code applicatif.</p></li>
<li><p>exposition du port d’écoute de l’application.</p></li>
<li><p>spécification de la commande à exécuter pour lancer le serveur.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple">
<li><p>Construire l’image en la taguant <code class="docutils literal notranslate"><span class="pre">pong:v1.0</span></code>.</p></li>
<li><p>Lancez un container basé sur cette image en publiant le <code class="docutils literal notranslate"><span class="pre">port</span> <span class="pre">80</span></code> sur le <code class="docutils literal notranslate"><span class="pre">port</span> <span class="pre">8080</span></code> de la machine hôte.</p></li>
<li><p>Tester l’application.</p></li>
<li><p>Supprimez le container.</p></li>
</ol>
</section>
<section id="exercice-3-entrypoint-et-cmd">
<h3>4.5.3 Exercice 3 : ENTRYPOINT et CMD<a class="headerlink" href="#exercice-3-entrypoint-et-cmd" title="Permalink to this headline">¶</a></h3>
<p>Nous allons illustrer sur plusieurs exemples l’utilisation des instructions <strong>ENTRYPOINT</strong> et <strong>CMD</strong>.
Ces instructions sont utilisées dans un <strong>Dockerfile</strong> pour définir la commande qui sera lancée dans un container.</p>
<section id="format">
<h4>Format<a class="headerlink" href="#format" title="Permalink to this headline">¶</a></h4>
<p>Dans un <strong>Dockerfile</strong>, les instructions <strong>ENTRYPOINT</strong> et <strong>CMD</strong> peuvent être spécifiées selon 2 formats:</p>
<ul class="simple">
<li><p>le format <code class="docutils literal notranslate"><span class="pre">shell</span></code>, ex: <code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span> <span class="pre">/usr/bin/node</span> <span class="pre">index.js</span></code>. Une commande spécifée dans ce format sera exécutée via un shell présent dans l’image. Cela peut notamment poser des problématiques car les signaux ne sont pas forwardés aux processus forkés.</p></li>
<li><p>le format <code class="docutils literal notranslate"><span class="pre">exec</span></code>, ex: <code class="docutils literal notranslate"><span class="pre">CMD</span> <span class="pre">[&quot;node&quot;,</span> <span class="pre">&quot;index.js&quot;]</span></code>. Une commande spécifiée dans ce format ne nécessitera pas la présence d’un shell dans l’image. On utilisera souvent le format exec pour ne pas avoir de problème si aucun shell n’est présent.</p></li>
</ul>
</section>
<section id="re-ecriture-a-lexecution-dun-container">
<h4>Ré-écriture à l’exécution d’un container<a class="headerlink" href="#re-ecriture-a-lexecution-dun-container" title="Permalink to this headline">¶</a></h4>
<p><strong>ENTRYPOINT</strong> et <strong>CMD</strong> sont 2 instructions du Dockerfile, mais elle peuvent cependant être écrasées au lancement d’un container:</p>
<ul class="simple">
<li><p>pour spécifier une autre valeur pour l’<strong>ENTRYPOINT</strong>, on utilisera l’option <code class="docutils literal notranslate"><span class="pre">--entrypoint</span></code>, par exemple: <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">container</span> <span class="pre">run</span> <span class="pre">--entrypoint</span> <span class="pre">echo</span> <span class="pre">alpine</span> <span class="pre">hello</span></code>.</p></li>
<li><p>pour spécifier une autre valeur pour CMD, on précisera celle-ci après le nom de l’image, par exemple: <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">container</span> <span class="pre">run</span> <span class="pre">alpine</span> <span class="pre">echo</span> <span class="pre">hello</span></code>.</p></li>
</ul>
</section>
<section id="instruction-entrypoint-utilisee-seule">
<h4>Instruction ENTRYPOINT utilisée seule<a class="headerlink" href="#instruction-entrypoint-utilisee-seule" title="Permalink to this headline">¶</a></h4>
<p>L’utilisation de l’instruction <strong>ENTRYPOINT</strong> seule permet de créer un wrapper autour de l’application.
Nous pouvons définir une commande de base et lui donner des paramètres suplémentaires, si nécessaire, au lancement d’un container.</p>
<p>Dans ce premier exemple, vous allez créer un fichier <strong>Dockerfile-v1</strong> contenant les instructions suivantes:</p>
<p>Créez ensuite une image, nommée <code class="docutils literal notranslate"><span class="pre">ping:1.0</span></code>, à partir de ce fichier.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">image</span> <span class="n">build</span> <span class="o">-</span><span class="n">f</span> <span class="n">Dockerfile</span><span class="o">-</span><span class="n">v1</span> <span class="o">-</span><span class="n">t</span> <span class="n">ping</span><span class="p">:</span><span class="mf">1.0</span> <span class="o">.</span>
</pre></div>
</div>
<p>Lancez maintenant un container basé sur l’image <strong>ping:1.0</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">run</span> <span class="n">ping</span><span class="p">:</span><span class="mf">1.0</span>
</pre></div>
</div>
<p>La commande <code class="docutils literal notranslate"><span class="pre">ping</span></code> est lancée dans le container (car elle est spécifiée dans <strong>ENTRYPOINT</strong>), ce qui produit le message suivant:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BusyBox</span> <span class="n">v1</span><span class="mf">.26.2</span> <span class="p">(</span><span class="mi">2017</span><span class="o">-</span><span class="mi">05</span><span class="o">-</span><span class="mi">23</span> <span class="mi">16</span><span class="p">:</span><span class="mi">46</span><span class="p">:</span><span class="mi">25</span> <span class="n">GMT</span><span class="p">)</span> <span class="n">multi</span><span class="o">-</span><span class="n">call</span> <span class="n">binary</span><span class="o">.</span>
<span class="n">Usage</span><span class="p">:</span> <span class="n">ping</span> <span class="p">[</span><span class="n">OPTIONS</span><span class="p">]</span> <span class="n">HOST</span>
<span class="n">Send</span> <span class="n">ICMP</span> <span class="n">ECHO_REQUEST</span> <span class="n">packets</span> <span class="n">to</span> <span class="n">network</span> <span class="n">hosts</span>
      <span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">6</span>           <span class="n">Force</span> <span class="n">IP</span> <span class="ow">or</span> <span class="n">IPv6</span> <span class="n">name</span> <span class="n">resolution</span>
      <span class="o">-</span><span class="n">c</span> <span class="n">CNT</span>          <span class="n">Send</span> <span class="n">only</span> <span class="n">CNT</span> <span class="n">pings</span>
      <span class="o">-</span><span class="n">s</span> <span class="n">SIZE</span>         <span class="n">Send</span> <span class="n">SIZE</span> <span class="n">data</span> <span class="nb">bytes</span> <span class="ow">in</span> <span class="n">packets</span> <span class="p">(</span><span class="n">default</span><span class="p">:</span><span class="mi">56</span><span class="p">)</span>
      <span class="o">-</span><span class="n">t</span> <span class="n">TTL</span>          <span class="n">Set</span> <span class="n">TTL</span>
      <span class="o">-</span><span class="n">I</span> <span class="n">IFACE</span><span class="o">/</span><span class="n">IP</span>     <span class="n">Use</span> <span class="n">interface</span> <span class="ow">or</span> <span class="n">IP</span> <span class="n">address</span> <span class="k">as</span> <span class="n">source</span>
      <span class="o">-</span><span class="n">W</span> <span class="n">SEC</span>          <span class="n">Seconds</span> <span class="n">to</span> <span class="n">wait</span> <span class="k">for</span> <span class="n">the</span> <span class="n">first</span> <span class="n">response</span> <span class="p">(</span><span class="n">default</span><span class="p">:</span><span class="mi">10</span><span class="p">)</span>
                      <span class="p">(</span><span class="n">after</span> <span class="nb">all</span> <span class="o">-</span><span class="n">c</span> <span class="n">CNT</span> <span class="n">packets</span> <span class="n">are</span> <span class="n">sent</span><span class="p">)</span>
      <span class="o">-</span><span class="n">w</span> <span class="n">SEC</span>          <span class="n">Seconds</span> <span class="n">until</span> <span class="n">ping</span> <span class="n">exits</span> <span class="p">(</span><span class="n">default</span><span class="p">:</span><span class="n">infinite</span><span class="p">)</span>
                      <span class="p">(</span><span class="n">can</span> <span class="n">exit</span> <span class="n">earlier</span> <span class="k">with</span> <span class="o">-</span><span class="n">c</span> <span class="n">CNT</span><span class="p">)</span>
      <span class="o">-</span><span class="n">q</span>              <span class="n">Quiet</span><span class="p">,</span> <span class="n">only</span> <span class="n">display</span> <span class="n">output</span> <span class="n">at</span> <span class="n">start</span>
                      <span class="ow">and</span> <span class="n">when</span> <span class="n">finished</span>
      <span class="o">-</span><span class="n">p</span>              <span class="n">Pattern</span> <span class="n">to</span> <span class="n">use</span> <span class="k">for</span> <span class="n">payload</span>
</pre></div>
</div>
<p>Par défaut, aucune machine hôte n’est ciblée, et à chaque lancement d’un container il est nécessaire de préciser un <strong>FQDN</strong> ou une <strong>IP</strong>.
La commande suivante lance un nouveau container en lui donnant l’adresse IP d’un DNS Google (<code class="docutils literal notranslate"><span class="pre">8.8.8.8</span></code>),
nous ajoutons également l’option <code class="docutils literal notranslate"><span class="pre">-c</span> <span class="pre">3</span></code> pour limiter le nombre de ping envoyés.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">run</span> <span class="n">ping</span><span class="p">:</span><span class="mf">1.0</span> <span class="o">-</span><span class="n">c</span> <span class="mi">3</span> <span class="mf">8.8.8.8</span>
</pre></div>
</div>
<p>Nous obtenons alors le résultat suivant :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PING</span> <span class="mf">8.8.8.8</span> <span class="p">(</span><span class="mf">8.8.8.8</span><span class="p">):</span> <span class="mi">56</span> <span class="n">data</span> <span class="nb">bytes</span>
<span class="mi">64</span> <span class="nb">bytes</span> <span class="kn">from</span> <span class="mf">8.8.8.8</span><span class="p">:</span> <span class="n">seq</span><span class="o">=</span><span class="mi">0</span> <span class="n">ttl</span><span class="o">=</span><span class="mi">37</span> <span class="n">time</span><span class="o">=</span><span class="mf">8.731</span> <span class="n">ms</span>
<span class="mi">64</span> <span class="nb">bytes</span> <span class="kn">from</span> <span class="mf">8.8.8.8</span><span class="p">:</span> <span class="n">seq</span><span class="o">=</span><span class="mi">1</span> <span class="n">ttl</span><span class="o">=</span><span class="mi">37</span> <span class="n">time</span><span class="o">=</span><span class="mf">8.503</span> <span class="n">ms</span>
<span class="mi">64</span> <span class="nb">bytes</span> <span class="kn">from</span> <span class="mf">8.8.8.8</span><span class="p">:</span> <span class="n">seq</span><span class="o">=</span><span class="mi">2</span> <span class="n">ttl</span><span class="o">=</span><span class="mi">37</span> <span class="n">time</span><span class="o">=</span><span class="mf">8.507</span> <span class="n">ms</span>
<span class="o">---</span> <span class="mf">8.8.8.8</span> <span class="n">ping</span> <span class="n">statistics</span> <span class="o">---</span>
<span class="mi">3</span> <span class="n">packets</span> <span class="n">transmitted</span><span class="p">,</span> <span class="mi">3</span> <span class="n">packets</span> <span class="n">received</span><span class="p">,</span> <span class="mi">0</span><span class="o">%</span>
<span class="nb">round</span><span class="o">-</span><span class="n">trip</span> <span class="nb">min</span><span class="o">/</span><span class="n">avg</span><span class="o">/</span><span class="nb">max</span> <span class="o">=</span> <span class="mf">8.503</span><span class="o">/</span><span class="mf">8.580</span><span class="o">/</span><span class="mf">8.731</span> <span class="n">ms</span>
</pre></div>
</div>
<p>La commande lancée dans le container est donc la concaténation de l’<strong>ENTRYPOINT</strong> et de la commande spécifiée lors du lancement du container (tout ce qui est situé après le nom de l’image).
Comme nous pouvons le voir dans cet exemple, l’image que nous avons créée est un wrapper autour de l’utilitaire <code class="docutils literal notranslate"><span class="pre">ping</span></code> et nécessite de spécifier des paramêtres supplémentaires au lancement d’un container.</p>
</section>
<section id="instructions-cmd-utilisee-seule">
<h4>Instructions CMD utilisée seule<a class="headerlink" href="#instructions-cmd-utilisee-seule" title="Permalink to this headline">¶</a></h4>
<p>De la même manière, il est possible de n’utiliser que l’instruction <strong>CMD</strong> dans un <strong>Dockerfile</strong>, c’est d’ailleurs très souvent l’approche qui est utilisée car il est plus simple de manipuler les instructions <strong>CMD</strong> que les <strong>ENTRYPOINT</strong>.
Créez un fichier <strong>Dockerfile-v2</strong> contenant les instructions suivantes:</p>
<p>Créez une image, nommée <strong>ping:2.0</strong> , à partir de ce fichier.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">image</span> <span class="n">build</span> <span class="o">-</span><span class="n">f</span> <span class="n">Dockerfile</span><span class="o">-</span><span class="n">v2</span> <span class="o">-</span><span class="n">t</span> <span class="n">ping</span><span class="p">:</span><span class="mf">2.0</span> <span class="o">.</span>
</pre></div>
</div>
<p>Si nous lançons maintenant un nouveau container, il lancera la commande ping comme c’était le cas avec l’exemple précédent dans lequel seul l’ENTRYPOINT était défini.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker container run ping:2.0

BusyBox v1.26.2 (2017-05-23 16:46:25 GMT) multi-call binary.
Usage: ping [OPTIONS] HOST
Send ICMP ECHO_REQUEST packets to network hosts
        -4,-6           Force IP or IPv6 name resolution
        -c CNT          Send only CNT pings
        -s SIZE         Send SIZE data bytes in packets (default:56)
        -t TTL          Set TTL
        -I IFACE/IP     Use interface or IP address as source
        -W SEC          Seconds to wait for the first response (default:10)
                        (after all -c CNT packets are sent)
        -w SEC          Seconds until ping exits (default:infinite)
                        (can exit earlier with -c CNT)
        -q              Quiet, only display output at start
                        and when finished
        -p              Pattern to use for payload
</pre></div>
</div>
<p>Nous n’avons cependant pas le même comportement que précédemment, car pour spécifier la machine à cibler, il faut redéfinir la commande complète à la suite du nom de l’image.</p>
<p>Si nous ne spécifions que les paramètres de la commande ping, nous obtenons un message d’erreur car la commande lancée dans le container ne peut pas être interpretée.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">run</span> <span class="n">ping</span><span class="p">:</span><span class="mf">2.0</span> <span class="o">-</span><span class="n">c</span> <span class="mi">3</span> <span class="mf">8.8.8.8</span>
</pre></div>
</div>
<p>Vous devriez alors obtenir l’erreur suivante:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">container_linux</span><span class="o">.</span><span class="n">go</span><span class="p">:</span><span class="mi">247</span><span class="p">:</span> <span class="n">starting</span> <span class="n">container</span> <span class="n">process</span> <span class="n">caused</span> <span class="s2">&quot;exec: </span><span class="se">\&quot;</span><span class="s2">-c</span><span class="se">\&quot;</span><span class="s2">: executable file not found in $PATH&quot;</span>
<span class="n">docker</span><span class="p">:</span> <span class="n">Error</span> <span class="n">response</span> <span class="kn">from</span> <span class="nn">daemon</span><span class="p">:</span> <span class="n">oci</span> <span class="n">runtime</span> <span class="n">error</span><span class="p">:</span> <span class="n">container_linux</span><span class="o">.</span><span class="n">go</span><span class="p">:</span><span class="mi">247</span><span class="p">:</span> <span class="n">starting</span> <span class="n">container</span> <span class="n">process</span> <span class="n">ca</span>
<span class="n">used</span> <span class="s2">&quot;exec: </span><span class="se">\&quot;</span><span class="s2">-c</span><span class="se">\&quot;</span><span class="s2">: executable file not found in $PATH&quot;</span><span class="o">.</span>
<span class="n">ERRO</span><span class="p">[</span><span class="mi">0000</span><span class="p">]</span> <span class="n">error</span> <span class="n">getting</span> <span class="n">events</span> <span class="kn">from</span> <span class="nn">daemon</span><span class="p">:</span> <span class="n">net</span><span class="o">/</span><span class="n">http</span><span class="p">:</span> <span class="n">request</span> <span class="n">canceled</span>
</pre></div>
</div>
<p>Il faut redéfinir la commande dans sa totalité, ce qui est fait en la spécifiant à la suite du nom de l’image.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker container run ping:2.0 ping -c 3 8.8.8.8
PING 8.8.8.8 (8.8.8.8): 56 data bytes
64 bytes from 8.8.8.8: seq=0 ttl=37 time=10.223 ms
64 bytes from 8.8.8.8: seq=1 ttl=37 time=8.523 ms
64 bytes from 8.8.8.8: seq=2 ttl=37 time=8.512 ms
--- 8.8.8.8 ping statistics ---
3 packets transmitted, 3 packets received, 0% packet loss
round-trip min/avg/max = 8.512/9.086/10.223 ms
</pre></div>
</div>
</section>
<section id="instructions-entrypoint-et-cmd">
<h4>Instructions ENTRYPOINT et CMD<a class="headerlink" href="#instructions-entrypoint-et-cmd" title="Permalink to this headline">¶</a></h4>
<p>Il est également possible d’utiliser ENTRYPOINT et CMD en même temps dans un Dockerfile, ce qui permet à la fois de créer un wrapper autour d’une application et de spécifier un comportement par défaut.</p>
<p>Nous allons illustrer cela sur un nouvel exemple et créer un fichier Dockerfile-v3 contenant les instructions suivantes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FROM</span> <span class="n">alpine</span>
<span class="n">ENTRYPOINT</span> <span class="p">[</span><span class="s2">&quot;ping&quot;</span><span class="p">]</span>
<span class="n">CMD</span> <span class="p">[</span><span class="s2">&quot;-c3&quot;</span><span class="p">,</span> <span class="s2">&quot;localhost&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>Ici, nous définissons ENTRYPOINT et CMD, la commande lancée dans un container sera la concaténation de ces 2 instructions: ping -c3 localhost.
Créez une image à partir de ce Dockerfile, nommez la ping:3.0, et lançez un nouveau container à partir de celle-ci.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker image build -f Dockerfile-v3 -t ping:3.0 .
$ docker container run ping:3.0
</pre></div>
</div>
<p>Vous devriez alors obtenir le résultat suivant:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PING</span> <span class="n">localhost</span> <span class="p">(</span><span class="mf">127.0.0.1</span><span class="p">):</span> <span class="mi">56</span> <span class="n">data</span> <span class="nb">bytes</span>
<span class="mi">64</span> <span class="nb">bytes</span> <span class="kn">from</span> <span class="mf">127.0.0.1</span><span class="p">:</span> <span class="n">seq</span><span class="o">=</span><span class="mi">0</span> <span class="n">ttl</span><span class="o">=</span><span class="mi">64</span> <span class="n">time</span><span class="o">=</span><span class="mf">0.062</span> <span class="n">ms</span>
<span class="mi">64</span> <span class="nb">bytes</span> <span class="kn">from</span> <span class="mf">127.0.0.1</span><span class="p">:</span> <span class="n">seq</span><span class="o">=</span><span class="mi">1</span> <span class="n">ttl</span><span class="o">=</span><span class="mi">64</span> <span class="n">time</span><span class="o">=</span><span class="mf">0.102</span> <span class="n">ms</span>
<span class="mi">64</span> <span class="nb">bytes</span> <span class="kn">from</span> <span class="mf">127.0.0.1</span><span class="p">:</span> <span class="n">seq</span><span class="o">=</span><span class="mi">2</span> <span class="n">ttl</span><span class="o">=</span><span class="mi">64</span> <span class="n">time</span><span class="o">=</span><span class="mf">0.048</span> <span class="n">ms</span>
<span class="o">---</span> <span class="n">localhost</span> <span class="n">ping</span> <span class="n">statistics</span> <span class="o">---</span>
<span class="mi">3</span> <span class="n">packets</span> <span class="n">transmitted</span><span class="p">,</span> <span class="mi">3</span> <span class="n">packets</span> <span class="n">received</span><span class="p">,</span> <span class="mi">0</span><span class="o">%</span> <span class="n">packet</span> <span class="n">loss</span>
<span class="nb">round</span><span class="o">-</span><span class="n">trip</span> <span class="nb">min</span><span class="o">/</span><span class="n">avg</span><span class="o">/</span><span class="nb">max</span> <span class="o">=</span> <span class="mf">0.048</span><span class="o">/</span><span class="mf">0.070</span><span class="o">/</span><span class="mf">0.102</span> <span class="n">ms</span>
</pre></div>
</div>
<p>Nous pouvons écraser la commande par défaut et spécifier une autre adresse IP</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">run</span> <span class="n">ping</span><span class="p">:</span><span class="mf">3.0</span> <span class="mf">8.8.8.8</span>
</pre></div>
</div>
<p>Nous obtenons alors le résultat suivant:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PING</span> <span class="mf">8.8.8.8</span> <span class="p">(</span><span class="mf">8.8.8.8</span><span class="p">):</span> <span class="mi">56</span> <span class="n">data</span> <span class="nb">bytes</span>
<span class="mi">64</span> <span class="nb">bytes</span> <span class="kn">from</span> <span class="mf">8.8.8.8</span><span class="p">:</span> <span class="n">seq</span><span class="o">=</span><span class="mi">0</span> <span class="n">ttl</span><span class="o">=</span><span class="mi">38</span> <span class="n">time</span><span class="o">=</span><span class="mf">9.235</span> <span class="n">ms</span>
<span class="mi">64</span> <span class="nb">bytes</span> <span class="kn">from</span> <span class="mf">8.8.8.8</span><span class="p">:</span> <span class="n">seq</span><span class="o">=</span><span class="mi">1</span> <span class="n">ttl</span><span class="o">=</span><span class="mi">38</span> <span class="n">time</span><span class="o">=</span><span class="mf">8.590</span> <span class="n">ms</span>
<span class="mi">64</span> <span class="nb">bytes</span> <span class="kn">from</span> <span class="mf">8.8.8.8</span><span class="p">:</span> <span class="n">seq</span><span class="o">=</span><span class="mi">2</span> <span class="n">ttl</span><span class="o">=</span><span class="mi">38</span> <span class="n">time</span><span class="o">=</span><span class="mf">8.585</span> <span class="n">ms</span>
</pre></div>
</div>
<p>Il faut alors faire un CTRL-C pour arrêter le container car l’option -c3 limitant le nombre de ping n’a pas été spécifiée.
Cela nous permet à la fois d’avoir un comportement par défaut et de pouvoir facilement le modifier en spécifiant une autre commande.</p>
</section>
<section id="pour-aller-plus-loin-ou-est-stockee-mon-image">
<h4>Pour aller plus loin : ou est stockée mon image ?<a class="headerlink" href="#pour-aller-plus-loin-ou-est-stockee-mon-image" title="Permalink to this headline">¶</a></h4>
</section>
<section id="stockage-d-une-image">
<h4>Stockage d’une image<a class="headerlink" href="#stockage-d-une-image" title="Permalink to this headline">¶</a></h4>
<p>Dans un exercice précédent, nous avons créé une image nommée ping:1.0, nous allons voir ici ou cette image est stockée.</p>
<p>Reprenons le Dockerfile de l’exercice :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FROM</span> <span class="n">ubuntu</span><span class="p">:</span><span class="mf">16.04</span>
<span class="n">RUN</span> <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">update</span> <span class="o">-</span><span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">install</span> <span class="o">-</span><span class="n">y</span> <span class="n">iputils</span><span class="o">-</span><span class="n">ping</span>
<span class="n">ENTRYPOINT</span> <span class="p">[</span><span class="s2">&quot;ping&quot;</span><span class="p">]</span>
<span class="n">CMD</span> <span class="p">[</span><span class="s2">&quot;8.8.8.8&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>A partir de ce Dockerfile, l’image est buildée avec la commande suivante :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker image build -t ping:1.0 .

Sending build context to Docker daemon  2.048kB
Step 1/4 : FROM ubuntu:16.04
---&gt; 5e8b97a2a082
Step 2/4 : RUN apt-get update -y &amp;&amp; apt-get install -y iputils-ping
---&gt; Using cache
---&gt; 4cd5304ad0fb
Step 3/4 : ENTRYPOINT [&quot;ping&quot;]
---&gt; Using cache
---&gt; d2846bbd30e8
Step 4/4 : CMD [&quot;8.8.8.8&quot;]
---&gt; Using cache
---&gt; 00a905f2bd5a
Successfully built 00a905f2bd5a
Successfully tagged ping:1.0
</pre></div>
</div>
<p>Pour lister les images présentes localement on utilise la commande <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">image</span> <span class="pre">ls</span></code> (on reverra cette commande un peu plus loin). Pour ne lister que les images qui ont le nom <code class="docutils literal notranslate"><span class="pre">ping</span></code> on le précise à la suite de <code class="docutils literal notranslate"><span class="pre">ls</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker image ls ping

REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
ping                1.0                 00a905f2bd5a        4 weeks ago         159MB
</pre></div>
</div>
<p>Notre image est constituée d’un ensemble de layers, il faut voir chaque layer comme un morceau de système de fichiers.
L’ID de l’image (dans sa version courte) est 00a905f2bd5a, nous allons voir à partir de cette identifiant comment l’image est stockée sur la machine hôte (la machine sur laquelle tourne le daemon Docker).</p>
<p>Tout se passe dans le répertoire <code class="docutils literal notranslate"><span class="pre">/var/lib/docker</span></code>, c’est le répertoire au Docker gère l’ensemble des primitives (containers, images, volumes, networks, …). Et plus précisément dans <code class="docutils literal notranslate"><span class="pre">/var/lib/docker/image/overlay2/</span></code>, overlay2 étant le driver en charge du stockage des images.</p>
<p><strong>Note:</strong> si vous utilisez <strong>Docker for Mac</strong> ou <strong>Docker for Windows</strong>, il est nécessaire d’utiliser la commande suivante pour lancer un <code class="docutils literal notranslate"><span class="pre">shell</span></code> dans la machine virtuelle dans laquelle tourne le daemon Docker. On pourra ensuite explorer le répertoire <code class="docutils literal notranslate"><span class="pre">/var/lib/docker</span></code> depuis ce shell.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">run</span> <span class="o">-</span><span class="n">it</span> <span class="o">--</span><span class="n">privileged</span> <span class="o">--</span><span class="n">pid</span><span class="o">=</span><span class="n">host</span> <span class="n">debian</span> <span class="n">nsenter</span> <span class="o">-</span><span class="n">t</span> <span class="mi">1</span> <span class="o">-</span><span class="n">m</span> <span class="o">-</span><span class="n">u</span> <span class="o">-</span><span class="n">n</span> <span class="o">-</span><span class="n">i</span> <span class="n">sh</span>
</pre></div>
</div>
<p>Plusieurs <strong>fichiers / répertoires</strong> ont un nom qui contient l’ID de notre image comme on peut le voir ci-dessous :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">docker</span><span class="o">/</span><span class="n">image</span><span class="o">/</span><span class="n">overlay2</span> <span class="c1"># find . | grep 00a905f2bd5a</span>
<span class="o">./</span><span class="n">imagedb</span><span class="o">/</span><span class="n">content</span><span class="o">/</span><span class="n">sha256</span><span class="o">/</span><span class="mi">00</span><span class="n">a905f2bd5aa3b1c4e28611704717679352a619bcdc4f8f6851cf459dc05816</span>
<span class="o">./</span><span class="n">imagedb</span><span class="o">/</span><span class="n">metadata</span><span class="o">/</span><span class="n">sha256</span><span class="o">/</span><span class="mi">00</span><span class="n">a905f2bd5aa3b1c4e28611704717679352a619bcdc4f8f6851cf459dc05816</span>
<span class="o">./</span><span class="n">imagedb</span><span class="o">/</span><span class="n">metadata</span><span class="o">/</span><span class="n">sha256</span><span class="o">/</span><span class="mi">00</span><span class="n">a905f2bd5aa3b1c4e28611704717679352a619bcdc4f8f6851cf459dc05816</span><span class="o">/</span><span class="n">lastUpdated</span>
<span class="o">./</span><span class="n">imagedb</span><span class="o">/</span><span class="n">metadata</span><span class="o">/</span><span class="n">sha256</span><span class="o">/</span><span class="mi">00</span><span class="n">a905f2bd5aa3b1c4e28611704717679352a619bcdc4f8f6851cf459dc05816</span><span class="o">/</span><span class="n">parent</span>
</pre></div>
</div>
<p><strong>- Content</strong> : le premier fichier contient un ensemble d’information concernant cette image, notamment les paramètres de configuration, l’historique de création (ensemble des commandes qui ont servi à construire le système de fichiers contenu dans l’image), et également l’ensemble des layers qui la constituent. Une grande partie de ces informations peuvent également être retrouvées avec la commande :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">image</span> <span class="n">inspect</span> <span class="n">ping</span><span class="p">:</span><span class="mf">1.0</span>
</pre></div>
</div>
<p>Parmi ces éléments, on a donc les identifiants de chaque layer :</p>
<div class="highlight-JSON notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;rootfs&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;layers&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="nt">&quot;diff_ids&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w"></span>
<span class="w">    </span><span class="s2">&quot;sha256:644879075e24394efef8a7dddefbc133aad42002df6223cacf98bd1e3d5ddde2&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="s2">&quot;sha256:d7ff1dc646ba52a02312b535446d6c9b72cd09fda0480524e4828554efb2f748&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="s2">&quot;sha256:686245e78935e73b737c9a82111c3c7df35f5529d06ce8c2f9a7cd32ec90b456&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="s2">&quot;sha256:d73dd9e652956dccbbef716de4b172cc15fff644cc92fc69d221cc3a1cb89a39&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="s2">&quot;sha256:2de391e51d731ba02b708038a7f98b7103061b916727bcd165e9ee6402f4cdde&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="s2">&quot;sha256:3045bfad4cfefecabc342600d368863445b12ed18188f5f2896c5389b0e84b66&quot;</span><span class="w"></span>
<span class="w">  </span><span class="p">]</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Si l’on considère la première layer (celle dont l’ID est 6448…), on voit dans <code class="docutils literal notranslate"><span class="pre">/var/lib/docker/image/overlay2</span></code> qu’il y a un répertoire dont le nom correspond à l’ID de cette layer, celui-ci contient plusieurs fichiers :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">docker</span><span class="o">/</span><span class="n">image</span><span class="o">/</span><span class="n">overlay2</span> <span class="c1"># find . | grep &#39;644879075e24394efef8a7dddefbc133aad42&#39;</span>
<span class="o">./</span><span class="n">layerdb</span><span class="o">/</span><span class="n">sha256</span><span class="o">/</span><span class="mf">644879075e24394</span><span class="n">efef8a7dddefbc133aad42002df6223cacf98bd1e3d5ddde2</span>
<span class="o">./</span><span class="n">layerdb</span><span class="o">/</span><span class="n">sha256</span><span class="o">/</span><span class="mf">644879075e24394</span><span class="n">efef8a7dddefbc133aad42002df6223cacf98bd1e3d5ddde2</span><span class="o">/</span><span class="n">size</span>
<span class="o">./</span><span class="n">layerdb</span><span class="o">/</span><span class="n">sha256</span><span class="o">/</span><span class="mf">644879075e24394</span><span class="n">efef8a7dddefbc133aad42002df6223cacf98bd1e3d5ddde2</span><span class="o">/</span><span class="n">tar</span><span class="o">-</span><span class="n">split</span><span class="o">.</span><span class="n">json</span><span class="o">.</span><span class="n">gz</span>
<span class="o">./</span><span class="n">layerdb</span><span class="o">/</span><span class="n">sha256</span><span class="o">/</span><span class="mf">644879075e24394</span><span class="n">efef8a7dddefbc133aad42002df6223cacf98bd1e3d5ddde2</span><span class="o">/</span><span class="n">diff</span>
<span class="o">./</span><span class="n">layerdb</span><span class="o">/</span><span class="n">sha256</span><span class="o">/</span><span class="mf">644879075e24394</span><span class="n">efef8a7dddefbc133aad42002df6223cacf98bd1e3d5ddde2</span><span class="o">/</span><span class="n">cache</span><span class="o">-</span><span class="nb">id</span>
<span class="o">./</span><span class="n">distribution</span><span class="o">/</span><span class="n">v2metadata</span><span class="o">-</span><span class="n">by</span><span class="o">-</span><span class="n">diffid</span><span class="o">/</span><span class="n">sha256</span><span class="o">/</span><span class="mf">644879075e24394</span><span class="n">efef8a7dddefbc133aad42002df6223cacf98bd1e3d</span>
</pre></div>
</div>
<p>Ceux-ci contiennent différentes information sur la layer en question. Parmi celles-ci, le fichier <strong>cache-id</strong> nous donne l’identifiant du cache qui a été généré pour cette layer.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">docker</span><span class="o">/</span><span class="n">image</span><span class="o">/</span><span class="n">overlay2</span> <span class="c1"># cat ./layerdb/sha256/644879075e24394efef8a7dddefbc133aad42002df6223cacf98bd1e3d5ddde2/cache-id</span>
<span class="mi">49908</span><span class="n">d07e177f9b61dc273ec7089efed9223d3798ad1d86c78d4fe953e227668</span>
</pre></div>
</div>
<p>Le système de fichier construit dans cette layer est alors accessible dans le répertoire :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">docker</span><span class="o">/</span><span class="n">overlay2</span><span class="o">/</span><span class="mi">49908</span><span class="n">d07e177f9b61dc273ec7089efed9223d3798ad1d86c78d4fe953e227668</span><span class="o">/</span><span class="n">diff</span><span class="o">/</span>
</pre></div>
</div>
<p><a href="#id3"><span class="problematic" id="id4">**</span></a>- LastUpdated <a href="#id5"><span class="problematic" id="id6">**</span></a>: ce fichier contient la date de dernière mise à jour de l’image</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">docker</span><span class="o">/</span><span class="n">image</span><span class="o">/</span><span class="n">overlay2</span> <span class="c1"># cat ./imagedb/metadata/sha256/00a905f2bd5...459dc05816/lastUpdated</span>
<span class="mi">2018</span><span class="o">-</span><span class="mi">07</span><span class="o">-</span><span class="mi">31</span><span class="n">T07</span><span class="p">:</span><span class="mi">32</span><span class="p">:</span><span class="mf">04.6840553</span><span class="n">Z</span>
</pre></div>
</div>
<p><strong>- parent</strong> : ce fichier contient l’identifiant du container qui a servi à créer l’image.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">docker</span><span class="o">/</span><span class="n">image</span><span class="o">/</span><span class="n">overlay2</span> <span class="c1"># cat ./imagedb/metadata/sha256/00a905f2bd5459dc05816/parent</span>
<span class="n">sha256</span><span class="p">:</span><span class="n">d2846bbd30e811ac8baaf759fc6c4f424c8df2365c42dab34d363869164881ae</span>
</pre></div>
</div>
<p>On retrouve d’ailleurs ce container dans l’avant dernière étape de création de l’image.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Step</span> <span class="mi">3</span><span class="o">/</span><span class="mi">4</span> <span class="p">:</span> <span class="n">ENTRYPOINT</span> <span class="p">[</span><span class="s2">&quot;ping&quot;</span><span class="p">]</span>
<span class="o">---&gt;</span> <span class="n">Using</span> <span class="n">cache</span>
<span class="o">---&gt;</span> <span class="n">d2846bbd30e8</span>
</pre></div>
</div>
<p>Ce container est celui qui a été commité pour créer l’image finale.</p>
<p><strong>En résumé :</strong> il est important de garder en tête qu’une image est constituée de plusieurs layers. Chaque layer est une partie du système de fichiers de l’image finale. C’est le rôle du driver de stockage de stocker ces différentes layers et de construire le système de fichiers de chaque container lancé à partir de cette image.</p>
</section>
</section>
</section>
<section id="multi-stages-build">
<h2>4.6 Multi-Stages Build<a class="headerlink" href="#multi-stages-build" title="Permalink to this headline">¶</a></h2>
<p>Depuis la version <code class="docutils literal notranslate"><span class="pre">17.05</span></code> de Docker, nous pouvons découper le Build d’une image en plusieurs étapes.</p>
<p>Un cas d’usage courant :</p>
<p><a href="#id7"><span class="problematic" id="id8">**</span></a>Etape 1 <a href="#id9"><span class="problematic" id="id10">**</span></a>: Avoir une image de base contenant l’ensemble des librairies et binaires nécessaires pour la création d’artéfacts.</p>
<p><strong>Etape 2</strong> : Utiliser une image de base plus light et d’y copier les artéfacts générés à l’étape précédente.</p>
<p><strong>Exemple :</strong></p>
<p>Considérons une application <strong>ReactJs</strong>.
Pour créer le squelette d’un projet React nous utilisons la commande :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">npm</span> <span class="n">init</span> <span class="n">react</span><span class="o">-</span><span class="n">app</span> <span class="n">api</span>
</pre></div>
</div>
<p>un dossier <code class="docutils literal notranslate"><span class="pre">api</span></code> est créé.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="n">api</span>
</pre></div>
</div>
<p>En utilisant le <strong>multistage build</strong> nous allons construire des artéfacts Web. Et nous aurons seulement besoin de copier ces artefacts dans un serveur <strong>WEB NGINX</strong> dans un second temps.</p>
<img alt="_images/image29.png" src="_images/image29.png" />
<p><strong>Dans le DockerFile</strong> :
La premiere instruction <strong>FROM</strong> utilise une image NODE dans laquelle les dépendances de l’application seront installées. Et le code applicatif Buildé.</p>
<p>Et la seconde instruction <strong>FROM</strong> utilise utilise une image <strong>NGINX</strong> dans laquelle les assets web buildés précédemment sont copiés. Et au final nous avons une seule image qui contient notre application.</p>
<p>Cela peut être vérifié en faisant le Build de l’image :</p>
<img alt="_images/image30.png" src="_images/image30.png" />
<section id="id11">
<h3>4.6.1 Mise en pratique<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<p>Dans cette mise en pratique, nous allons illustrer le multi stage build.</p>
<section id="rappel">
<h4>Rappel<a class="headerlink" href="#rappel" title="Permalink to this headline">¶</a></h4>
<p>Comme nous l’avons vu, le Dockerfile contient une liste d’instructions qui permet de créer une image. La première instruction est FROM, elle définit l’image de base utilisée. Cette image de base contient souvent beaucoup d’éléments (binaires et librairies) dont l’application finale n’a pas besoin (compilateur, …). Ceci qui peut impacter de façon considérable la taille de l’image et également sa sécurité puisque cela peut considérablement augmenter sa surface d’attaque. C’est la qu’intervint le multistage build…</p>
</section>
<section id="un-serveur-http-ecrit-en-go">
<h4>Un serveur http écrit en Go<a class="headerlink" href="#un-serveur-http-ecrit-en-go" title="Permalink to this headline">¶</a></h4>
<p>Prenons l’exemple du programme suivant écrit en Go.</p>
<p>Dans un nouveau répertoire, créez le fichier http.go contenant le code suivant. Celui-ci définit un simple serveur http qui écoute sur le port 8080 et qui expose le endpoint /whoami en GET. A chaque requête, il renvoie le nom de la machine hôte sur laquelle il tourne.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">package</span> <span class="n">main</span>
<span class="kn">import</span> <span class="p">(</span>
        <span class="s2">&quot;io&quot;</span>
        <span class="s2">&quot;net/http&quot;</span>
        <span class="s2">&quot;os&quot;</span>
<span class="p">)</span>
<span class="n">func</span> <span class="n">handler</span><span class="p">(</span><span class="n">w</span> <span class="n">http</span><span class="o">.</span><span class="n">ResponseWriter</span><span class="p">,</span> <span class="n">req</span> <span class="o">*</span><span class="n">http</span><span class="o">.</span><span class="n">Request</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">host</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">os</span><span class="o">.</span><span class="n">Hostname</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="n">nil</span> <span class="p">{</span>
         <span class="n">io</span><span class="o">.</span><span class="n">WriteString</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="s2">&quot;unknown&quot;</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="n">io</span><span class="o">.</span><span class="n">WriteString</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">host</span><span class="p">)</span>
        <span class="p">}</span>
<span class="p">}</span>
<span class="n">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">http</span><span class="o">.</span><span class="n">HandleFunc</span><span class="p">(</span><span class="s2">&quot;/whoami&quot;</span><span class="p">,</span> <span class="n">handler</span><span class="p">)</span>
        <span class="n">http</span><span class="o">.</span><span class="n">ListenAndServe</span><span class="p">(</span><span class="s2">&quot;:8080&quot;</span><span class="p">,</span> <span class="n">nil</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="dockerfile-traditionel">
<h4>Dockerfile traditionel<a class="headerlink" href="#dockerfile-traditionel" title="Permalink to this headline">¶</a></h4>
<p>Afin de créer une image pour cette application, créez tout dabord le fichier Dockerfile avec le contenu suivant (placez ce fichier dans le même répertoire que http.go):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FROM</span> <span class="n">golang</span><span class="p">:</span><span class="mf">1.17</span>
<span class="n">WORKDIR</span> <span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">app</span>
<span class="n">COPY</span> <span class="n">http</span><span class="o">.</span><span class="n">go</span> <span class="o">.</span>
<span class="n">RUN</span> <span class="n">go</span> <span class="n">mod</span> <span class="n">init</span>
<span class="n">RUN</span> <span class="n">CGO_ENABLED</span><span class="o">=</span><span class="mi">0</span> <span class="n">GOOS</span><span class="o">=</span><span class="n">linux</span> <span class="n">go</span> <span class="n">build</span> <span class="o">-</span><span class="n">o</span> <span class="n">http</span> <span class="o">.</span>
<span class="n">CMD</span> <span class="p">[</span><span class="s2">&quot;./http&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>Note: dans ce Dockerfile, l’image officielle golang est utilisée comme image de base, le fichier source http.go est copié puis compilé.</p>
<p>Vous pouvez ensuite builder l’image et la nommer whoami:1.0:.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">image</span> <span class="n">build</span> <span class="o">-</span><span class="n">t</span> <span class="n">whoami</span><span class="p">:</span><span class="mf">1.0</span> <span class="o">.</span>
</pre></div>
</div>
<p>Listez les images présentes et notez la taille de l’image whoami:1.0</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker image ls whoami
  REPOSITORY   TAG       IMAGE ID       CREATED         SIZE
  whoami       1.0       16795cf36deb   2 seconds ago   962MB
</pre></div>
</div>
<p>L’image obtenue a une taille très conséquente car elle contient l’ensemble de la toolchain du langage Go. Or, une fois que le binaire a été compilé, nous n’avons plus besoin du compilateur dans l’image finale.</p>
</section>
<section id="dockerfile-utilisant-un-build-multi-stage">
<h4>Dockerfile utilisant un build multi-stage<a class="headerlink" href="#dockerfile-utilisant-un-build-multi-stage" title="Permalink to this headline">¶</a></h4>
<p>Le multi-stage build, introduit dans la version 17.05 de Docker permet, au sein d’un seul Dockerfile, d’effectuer le process de build en plusieurs étapes. Chacune des étapes peut réutiliser des artefacts (fichiers résultant de compilation, assets web, …) créés lors des étapes précédentes. Ce Dockerfile aura plusieurs instructions FROM mais seule la dernière sera utilisée pour la construction de l’image finale.</p>
<p>Si nous reprenons l’exemple du serveur http ci dessus, nous pouvons dans un premier temps compiler le code source en utilisant l’image golang contenant le compilateur. Une fois le binaire créé, nous pouvons utiliser une image de base vide, nommée scratch, et copier le binaire généré précédemment.</p>
<p>Remplacer le contenu du fichier Dockerfile avec les instructions suivantes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FROM</span> <span class="n">golang</span><span class="p">:</span><span class="mf">1.17</span> <span class="k">as</span> <span class="n">build</span>
<span class="n">WORKDIR</span> <span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">app</span>
<span class="n">COPY</span> <span class="n">http</span><span class="o">.</span><span class="n">go</span> <span class="o">.</span>
<span class="n">RUN</span> <span class="n">go</span> <span class="n">mod</span> <span class="n">init</span>
<span class="n">RUN</span> <span class="n">CGO_ENABLED</span><span class="o">=</span><span class="mi">0</span> <span class="n">GOOS</span><span class="o">=</span><span class="n">linux</span> <span class="n">go</span> <span class="n">build</span> <span class="o">-</span><span class="n">o</span> <span class="n">http</span> <span class="o">.</span>

<span class="n">FROM</span> <span class="n">scratch</span>
<span class="n">COPY</span> <span class="o">--</span><span class="n">from</span><span class="o">=</span><span class="n">build</span> <span class="o">/</span><span class="n">go</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">app</span> <span class="o">.</span>
<span class="n">CMD</span> <span class="p">[</span><span class="s2">&quot;./http&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>L’exemple que nous avons utilisé ici se base sur une application écrite en Go. ce langage a la particularité de pouvoir être compilé en un binaire static, c’est à dire ne nécessitant pas d’être “linké” à des librairies externes. C’est la raison pour laquelle nous pouvons partir de l’image scratch. Pour d’autres langages, l’image de base utilisée lors de la dernière étape du build pourra être différente (alpine, …)</p>
<p>Buildez l’image dans sa version 2 avec la commande suivante.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">image</span> <span class="n">build</span> <span class="o">-</span><span class="n">t</span> <span class="n">whoami</span><span class="p">:</span><span class="mf">2.0</span> <span class="o">.</span>
</pre></div>
</div>
<p>Listez les images et observez la différence de taille entre celles-ci:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker image ls whoami
  REPOSITORY   TAG       IMAGE ID       CREATED         SIZE
  whoami       2.0       0a97315aeaaa   6 seconds ago   6.07MB
  whoami       1.0       16795cf36deb   2 minutes ago   962MB
</pre></div>
</div>
<p>Lancez un container basé sur l’image whoami:2.0</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">container</span> <span class="n">run</span> <span class="o">-</span><span class="n">p</span> <span class="mi">8080</span><span class="p">:</span><span class="mi">8080</span> <span class="n">whoami</span><span class="p">:</span><span class="mf">2.0</span>
</pre></div>
</div>
<p>A l’aide de la commande curl, envoyez une requête GET sur le endpoint exposé. Vous devriez avoir, en retour, l’identifiant du container qui a traité la requète.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ curl localhost:8080/whoami
  7562306c6c5e
</pre></div>
</div>
<p>Pour cette simple application, le multistage build a permit de supprimer les binaires et librairies dont la présence est inutile dans l’image finale. L’exemple d’une application écrite en go est extrème, mais le multistage build fait partie des bonnes pratiques à adopter pour de nombreux languages de développement.</p>
</section>
</section>
</section>
<section id="prise-en-compte-du-cache">
<h2>4.7 Prise en compte du cache<a class="headerlink" href="#prise-en-compte-du-cache" title="Permalink to this headline">¶</a></h2>
<p>Quand on écrit un Dockerfile, on doit prendre en compte le mécanisme de cache.</p>
<p>Pour optimiser le temps nécessaire pour construire l’image.</p>
<p>Quand une image est créée chaque instruction créée une layer et en fonction de la complexité du Dockerfile, le premier build peut prendre un peu de temps mais les suivant seront très rapide parce que les layers existantes seront réutilisés.</p>
<p>Un Dockerfile qui est créé doit s’assurer que le cache est bien utilisé.</p>
<p>On peut l’utiliser pour reconstruire une image après qu’un changement ait été effectué, dans un fichier de configuration par exemple de sorte qu’il empêche le code source d’être compilé à nouveau si cela n’est pas nécessaire.</p>
<p>Il y a plusieurs façons de forcer la recréation des layers d’une image si besoin.
Notamment par la modification de la valeur d’une variable d’environnement ou si on modifie le code source qui est pris en compte dans les instructions ADD ou COPY.</p>
<p>Si une instruction invalide le cache, alors toutes les instructions après ne l’utiliseront pas.</p>
<p>A partir de l’exemple de l’application NODEJS vue précédemment :</p>
<img alt="_images/image31.png" src="_images/image31.png" />
<p>Si on lance une nouvelle fois le build de l’image on voit que pour chaque instruction le cache est utilisé.
Cela signifie que pour chaque instruction la layer qui a déjà été créé, la première version, est réutilisé.
Lorsque que l’image est créée pour la première fois, cela prend un peu de temps car il faut récupérer les dépendances et l’image.
Mais à l’aide du cache cela prend quelque seconde.</p>
<p>Faites l’expérience :
Dans le dossier contenant l’application NODEJS, tapez la commande :</p>
<p>Docker image build -t app :0.1 .</p>
<img alt="_images/image21.png" src="_images/image21.png" />
<p>Nous allons maintenant modifier le code de l’application.
Ouvrons : index.js et modifions le label</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">express</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;express&#39;</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">util</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;util&#39;</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">app</span> <span class="o">=</span> <span class="nx">express</span><span class="p">();</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">setHeader</span><span class="p">(</span><span class="s1">&#39;Content-Type&#39;</span><span class="p">,</span> <span class="s1">&#39;text/plain&#39;</span><span class="p">);</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">end</span><span class="p">(</span><span class="nx">util</span><span class="p">.</span><span class="nx">format</span><span class="p">(</span><span class="s1">&#39;%s - %s\n&#39;</span><span class="p">,</span> <span class="ow">new</span> <span class="nb">Date</span><span class="p">(),</span> <span class="s1">&#39;==&gt; Test Modification&#39;</span><span class="p">));</span>
<span class="p">});</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">PORT</span> <span class="o">||</span> <span class="mf">8080</span><span class="p">);</span>
</pre></div>
</div>
<p>et rebuildons l’image</p>
<img alt="_images/image22.png" src="_images/image22.png" />
<p>Lorsque l’on a changé le code source, cela a entrainé la reconstruction des dépendances de package.json.
Ici ce n’est pas très long car nous n’avons que le package Express mais dans des applications plus lourdes cela peut impacter les performances.</p>
<p>Pour éviter ce problème nous allons modifier le DockerFile.</p>
<p>Nous allons faire en sorte de séparer le COPY en deux.</p>
<p>Dans le premier nous ne copierons que le fichier PACKAGE.JSON.
Puis nous déplacerons l’instruction RUN de façon à récupérer les dépendances.</p>
<p>Ensuite nous copierons le code applicatif.</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">FROM</span> <span class="nx">node</span><span class="o">:</span><span class="nx">current</span><span class="o">-</span><span class="nx">alpine3</span><span class="mf">.15</span>
<span class="nx">COPY</span> <span class="kr">package</span><span class="p">.</span><span class="nx">json</span> <span class="o">/</span><span class="nx">app</span><span class="o">/</span><span class="kr">package</span><span class="p">.</span><span class="nx">json</span>
<span class="nx">RUN</span> <span class="nx">cd</span> <span class="o">/</span><span class="nx">app</span> <span class="o">&amp;&amp;</span> <span class="nx">npm</span> <span class="nx">install</span>
<span class="nx">COPY</span> <span class="p">.</span> <span class="o">/</span><span class="nx">app</span><span class="o">/</span>
<span class="nx">EXPOSE</span> <span class="mf">8080</span>
<span class="nx">WORKDIR</span> <span class="o">/</span><span class="nx">app</span>
<span class="nx">CMD</span> <span class="p">[</span><span class="s2">&quot;npm&quot;</span><span class="p">,</span> <span class="s2">&quot;start&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>Nous rebuildons ensuite notre image.
Le cache n’est pas utilisé car le DOCKERFILE a été modifié alors tout est reconstruit.</p>
<p>Remodifions le code source.</p>
<img alt="_images/image46.png" src="_images/image46.png" />
<p>Le code source est rechargé sans avoir à reconstruire les dépendances.</p>
<section id="exercice-prise-en-compte-du-cache">
<h3>4.7.1 Exercice : Prise en compte du cache<a class="headerlink" href="#exercice-prise-en-compte-du-cache" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li><p>Modifiez le code du serveur pong de l’exercice précédent. Vous pouvez par exemple ajouter une instruction qui loggue une chaine de caractère.</p></li>
<li><p>Construisez une nouvelle image en la taguant pong:1.1</p></li>
<li><p>Qu’observez-vous dans la sortie de la commande de build ?</p></li>
<li><p>Modifiez le Dockerfile pour faire en sorte que les dépendances ne soient pas rebuildées si un changement est effectué dans le code. Créez l’image pong:1.2 à partir de ce nouveau Dockerfile.</p></li>
<li><p>Modifiez une nouvelle fois le code de l’application et créez l’image pong:1.3. Observez la prise en compte du cache</p></li>
</ol>
</section>
</section>
<section id="le-contexte-de-build">
<h2>4.8 Le contexte de Build<a class="headerlink" href="#le-contexte-de-build" title="Permalink to this headline">¶</a></h2>
<p>Quand on construit une image Docker avec la commande Docker image build.
La première chose que le client Docker fait, c’est d’envoyer au Daemon, sous forme d’une archive Tar, l’ensemble des fichiers nécessaire pour construire le système de fichier de l’image.
Cet ensemble constitue le Build Context.
Par défaut, c’est tout les fichiers qui sont envoyés. Cela peut être dangereux si l’on a des informations sensibles.
D’où l’intérêt d’utiliser un fichier .DOCKERIGNORE pour filtrer les fichier et les répertoires qui ne doivent pas être répertorié par le contexte de build.</p>
<p>C’est le même principe que le fichier .gitignore sur GIT par exemple.</p>
<p>Reprenons l’exemple de notre application NODEJS.</p>
<p>Refaisons un build :</p>
<img alt="_images/image47.png" src="_images/image47.png" />
<p>Durant le build nous constatons qu’avant de transférer le context de build au Daemon Docker, on essaie de charger le fichier .dockerignore.</p>
<p>Le contexte ici, correspond au répertoire courant symbolisé par le « . » à la fin de la commande docker image build.</p>
<p>On ne veut pas forcement que certains fichiers arrivent au Docker Daemon, comme un historique GIT ou de données sensibles comme des mots de passe stockés dans un fichier ENV ..ETC</p>
<p>Testons cela, en créant un dépôt git :</p>
<p>Dans le répertoire du projet NODEJS :</p>
<p>Git init</p>
<img alt="_images/image48.png" src="_images/image48.png" />
<p>Et relançons le build :</p>
<p>Et constatons que le context transféré passe de : 21.28 Kb à 46.15kb. Cela signifie que l’ensemble des répertoires de git ont été transféré dans le Docker Daemon.</p>
<p>Créons donc un fichier .dockerignore et ajoutons le dossier .git.</p>
<img alt="_images/image49.png" src="_images/image49.png" />
<img alt="_images/image50.png" src="_images/image50.png" />
<p>Relançons le build et constatons la taille du context :</p>
<p>=&gt; =&gt; transferring context: 21.02kB</p>
<p>Le .GIT n’est plus envoyé dans le context.</p>
<p>Dans une application NODEJS, nous pourrions aussi ajouter le répertoire node_module qui contient les dépendances de l’application dans le .dockerignore.</p>
</section>
<section id="les-commandes-de-base-avec-docker-image">
<h2>4.9 Les commandes de base avec docker image.<a class="headerlink" href="#les-commandes-de-base-avec-docker-image" title="Permalink to this headline">¶</a></h2>
<p><strong>La commande PULL.</strong></p>
<p>Permet de télécharger une image à partir d’un registry, par défault : Docker Hub.</p>
<img alt="_images/image51.png" src="_images/image51.png" />
<p>Format de nommage : USER/IMAGE :VERSION</p>
<p>Si l’on ne précise pas de numéro de version, par défaut c’est « latest » qui est retenu.</p>
<p><strong>La commande : push</strong></p>
<p>La commande Push permet d’uploader une image dans un registry.
Pour cela il faut avoir les droits sur ses images.
Mais avant il faut avoir précisé ses identifiants de connexion au registry avec docker login.</p>
<p><strong>La commande : Inspect</strong></p>
<p>Permet de voir la liste des layer qui composent une image.  On peut utiliser ici aussi le formaliste Go Template.</p>
<img alt="_images/image52.png" src="_images/image52.png" />
<p><strong>La commande : History</strong></p>
<p>Permet de voir l’historique d’une image.</p>
<p><strong>La commande : ls</strong></p>
<p>Permet d’énumérer les images localement.</p>
<img alt="_images/image53.png" src="_images/image53.png" />
<p><strong>Les commandes Save et Load.</strong></p>
<p>Save permet de sauvegarder une image
et Load permet de charger une image à partir d’une sauvegarde.</p>
<img alt="_images/image44.png" src="_images/image44.png" />
<p><a href="#id12"><span class="problematic" id="id13">**</span></a>La commande : rm **</p>
<p>Supprime une image avec l’ensemble de ses layers.
Plusieurs images peuvent être supprimées en même temps.</p>
<img alt="_images/image45.png" src="_images/image45.png" />
<section id="exercice-analyse-du-contenu-d-une-image">
<h3>4.9.1 Exercice : Analyse du contenu d’une image<a class="headerlink" href="#exercice-analyse-du-contenu-d-une-image" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li><p>Télécharger l’image mongo:3.6 en local</p></li>
<li><p>Quelles sont les différentes étapes de constructions de l’image</p></li>
</ol>
<p>Comparez ces étapes avec le contenu du Dockerfile utilsé pour builder cette image.</p>
<ol class="arabic simple">
<li><p>Inspectez l’image</p></li>
<li><p>En utilisant la notation Go template, listez les ports exposés</p></li>
<li><p>Exportez l’image mongo:3.6 dans un tar</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Extrayez le contenu de cette archive avec la commande tar -xvf, qu’observez-vous ?</p></li>
<li><p>Extrayez le contenu d’une des layers, qu’observez-vous ?</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple">
<li><p>Supprimez l’image mongo:3.6</p></li>
</ol>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Cours BTS SIO</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="cours/docker/1.0%20Introduction.html">1.0 Introduction</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, Bauer Baptiste.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.4.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/docker.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>